From 0335df11b577aa04c4e875a184e010ebaa011140 Mon Sep 17 00:00:00 2001
From: "Anton D. Kachalov" <mouse@yandex-team.ru>
Date: Tue, 24 May 2016 19:36:09 +0300
Subject: [PATCH 05/14] Add AST ethernet

Signed-off-by: Anton D. Kachalov <mouse@yandex-team.ru>
---
 drivers/net/ethernet/Kconfig            |    4 +
 drivers/net/ethernet/Makefile           |    1 +
 drivers/net/ethernet/aspeed/Kconfig     |   37 +
 drivers/net/ethernet/aspeed/Makefile    |    8 +
 drivers/net/ethernet/aspeed/ast_ether.c | 1617 ++++++++++++++++++++
 drivers/net/ethernet/aspeed/ast_ether.h |  330 +++++
 drivers/net/ethernet/aspeed/ast_gmac.c  | 2441 +++++++++++++++++++++++++++++++
 drivers/net/ethernet/aspeed/ast_gmac.h  |  585 ++++++++
 drivers/net/ethernet/aspeed/dev-eth.c   |  114 ++
 drivers/net/ethernet/aspeed/ftgmac100.c | 1379 +++++++++++++++++
 drivers/net/ethernet/aspeed/ftgmac100.h |  251 ++++
 11 files changed, 6767 insertions(+)
 create mode 100644 drivers/net/ethernet/aspeed/Kconfig
 create mode 100644 drivers/net/ethernet/aspeed/Makefile
 create mode 100644 drivers/net/ethernet/aspeed/ast_ether.c
 create mode 100644 drivers/net/ethernet/aspeed/ast_ether.h
 create mode 100644 drivers/net/ethernet/aspeed/ast_gmac.c
 create mode 100644 drivers/net/ethernet/aspeed/ast_gmac.h
 create mode 100644 drivers/net/ethernet/aspeed/dev-eth.c
 create mode 100644 drivers/net/ethernet/aspeed/ftgmac100.c
 create mode 100644 drivers/net/ethernet/aspeed/ftgmac100.h

diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
index 1ed1fbb..a2dc7ef 100644
--- a/drivers/net/ethernet/Kconfig
+++ b/drivers/net/ethernet/Kconfig
@@ -11,6 +11,10 @@ menuconfig ETHERNET
 
 if ETHERNET
 
+config AST
+	tristate
+source "drivers/net/ethernet/aspeed/Kconfig"
+
 config MDIO
 	tristate
 
diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
index 6e0b629..1d71f4e 100644
--- a/drivers/net/ethernet/Makefile
+++ b/drivers/net/ethernet/Makefile
@@ -84,3 +84,4 @@ obj-$(CONFIG_NET_VENDOR_VIA) += via/
 obj-$(CONFIG_NET_VENDOR_WIZNET) += wiznet/
 obj-$(CONFIG_NET_VENDOR_XILINX) += xilinx/
 obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
+obj-$(CONFIG_NET_ASPEED_MAC)    += aspeed/
diff --git a/drivers/net/ethernet/aspeed/Kconfig b/drivers/net/ethernet/aspeed/Kconfig
new file mode 100644
index 0000000..4727371
--- /dev/null
+++ b/drivers/net/ethernet/aspeed/Kconfig
@@ -0,0 +1,37 @@
+#
+# ASPEED network device configuration
+#
+
+config NET_ASPEED_MAC
+	bool "AST MAC devices"
+	default y
+	---help---
+	  If you want to enable the network (Ethernet) support for AST SOC, say Y
+
+
+if NET_ASPEED_MAC
+
+config ASTMAC100
+	tristate "Aspeed MAC100 support"
+	depends on ETHERNET && BASESOC_AST
+	default y
+	select PHYLIB
+	---help---
+	  This driver enables the latest ethernet driver from ASPEED for AST SOC.
+
+
+config LEGACY_ASTMAC100
+	tristate "Aspeed Legacy MAC100 support"
+	depends on ETHERNET && BASESOC_AST
+	default y
+	select PHYLIB
+	---help---
+	  This driver enables the legacy etherner driver from ASPEED for AST SOC.
+
+config AST_PHY_ADDR
+	int "AST MAC MII PHY Address" if ASTMAC100
+	default 31
+	---help---
+	  Phy Address for MAC devices
+
+endif # NET_ASPEED_MAC
diff --git a/drivers/net/ethernet/aspeed/Makefile b/drivers/net/ethernet/aspeed/Makefile
new file mode 100644
index 0000000..e29d8fc
--- /dev/null
+++ b/drivers/net/ethernet/aspeed/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for the Aspeed network device driver.
+#
+
+#obj-$(CONFIG_ASTMAC100)     += ftgmac100.o
+obj-$(CONFIG_ASTMAC100)     += ast_gmac.o
+obj-$(CONFIG_ASTMAC100)     += dev-eth.o
+obj-$(CONFIG_LEGACY_ASTMAC100)     += ast_ether.o
diff --git a/drivers/net/ethernet/aspeed/ast_ether.c b/drivers/net/ethernet/aspeed/ast_ether.c
new file mode 100644
index 0000000..a6f2d5f
--- /dev/null
+++ b/drivers/net/ethernet/aspeed/ast_ether.c
@@ -0,0 +1,1617 @@
+/*
+ * drivers/net/ast_ether.c - AST2050/AST2100/AST2150/AST2200 ethernet MAC driver
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/crc32.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/rtnetlink.h>
+
+#include "ast_ether.h"
+
+#if (AST_ETHER_MAX_NUM == 4)
+const unsigned long ast_ether_phys_base[AST_ETHER_MAX_NUM] = { AST_ETHER_REG_BASE1, AST_ETHER_REG_BASE2,
+                                                               AST_ETHER_REG_BASE3, AST_ETHER_REG_BASE4 };
+const unsigned long ast_ether_irq[AST_ETHER_MAX_NUM] = { AST_ETHER_IRQ1, AST_ETHER_IRQ2,
+                                                         AST_ETHER_IRQ3, AST_ETHER_IRQ4 };
+#elif (AST_ETHER_MAX_NUM == 3)
+const unsigned long ast_ether_phys_base[AST_ETHER_MAX_NUM] = { AST_ETHER_REG_BASE1, AST_ETHER_REG_BASE2, 
+                                                               AST_ETHER_REG_BASE3 };
+const unsigned long ast_ether_irq[AST_ETHER_MAX_NUM] = { AST_ETHER_IRQ1, AST_ETHER_IRQ2, 
+                                                         AST_ETHER_IRQ3 };
+#elif (AST_ETHER_MAX_NUM == 2)
+const unsigned long ast_ether_phys_base[AST_ETHER_MAX_NUM] = {AST_ETHER_REG_BASE1, AST_ETHER_REG_BASE2};
+const unsigned long ast_ether_irq[AST_ETHER_MAX_NUM] = {AST_ETHER_IRQ1, AST_ETHER_IRQ2};
+#elif (AST_ETHER_MAX_NUM == 1)
+const unsigned long ast_ether_phys_base[AST_ETHER_MAX_NUM] = {AST_ETHER_REG_BASE1};
+const unsigned long ast_ether_irq[AST_ETHER_MAX_NUM] = {AST_ETHER_IRQ1};
+#else
+    #error "Not Supported SOC!"
+#endif
+
+static struct net_device *ast_ether_netdev[AST_ETHER_MAX_NUM];
+
+extern unsigned long enetaddr[][6];
+#ifdef BROADCAST_BLACKLIST
+static struct ast_bc ast_ether_bc[AST_ETHER_MAX_NUM];
+#endif
+static void ast_ether_free_rx_buf(struct net_device *dev);
+//int phy_ad = 0 ;
+
+static void ast_ether_get_hardware_addr(struct net_device* dev)
+{
+	struct ast_ether_priv *priv;
+	priv = netdev_priv(dev);
+
+	memcpy(dev->dev_addr, enetaddr[priv->idx], ETH_ALEN);
+}
+
+static void ast_ether_phy_rw_waiting(unsigned int ioaddr)
+{
+	int count;
+
+	count = 0;
+	while (inl(ioaddr + AST_ETHER_PHYCR) & (PHYCR_READ | PHYCR_WRITE)) {
+		mdelay(10);
+		count ++;
+		if (count > 100)
+			break;
+	}
+}
+
+/* Reads a register from the MII Management serial interface */
+static u16 ast_ether_phy_read_register(struct net_device *dev, u8 phyaddr, u8 phyreg)
+{
+	unsigned int ioaddr = dev->base_addr;
+	u32 reg_val;
+	
+	reg_val = inl(ioaddr + AST_ETHER_PHYCR);
+
+	reg_val &= ~(PHYCR_WRITE | PHYCR_READ | PHYCR_REGAD_MASK | PHYCR_PHYAD_MASK); /* clear PHYAD, REGAD, MIIRD, MIIWR */
+	reg_val |= (phyaddr << PHYCR_PHYAD_SHIFT) & PHYCR_PHYAD_MASK;
+	reg_val |= (phyreg << PHYCR_REGAD_SHIFT) & PHYCR_REGAD_MASK;
+	reg_val |= PHYCR_READ;
+	
+	outl(reg_val, ioaddr + AST_ETHER_PHYCR);
+	
+	ast_ether_phy_rw_waiting(ioaddr);
+
+	return ((inl(ioaddr + AST_ETHER_PHYDATA) >> 16));
+}
+
+/* Writes a register to the MII Management serial interface */
+static void ast_ether_phy_write_register(struct net_device *dev, u8 phyaddr, u8 phyreg, u16 phydata)
+{
+	unsigned int ioaddr = dev->base_addr;
+	u32 reg_val;
+
+	reg_val = inl(ioaddr + AST_ETHER_PHYCR);
+
+	reg_val &= ~(PHYCR_WRITE | PHYCR_READ | PHYCR_REGAD_MASK | PHYCR_PHYAD_MASK); /* clear PHYAD, REGAD, MIIRD, MIIWR */
+	reg_val |= (phyaddr << PHYCR_PHYAD_SHIFT) & PHYCR_PHYAD_MASK;
+	reg_val |= (phyreg << PHYCR_REGAD_SHIFT) & PHYCR_REGAD_MASK;
+	reg_val |= PHYCR_WRITE;
+
+	outl(phydata, ioaddr + AST_ETHER_PHYDATA);
+	outl(reg_val, ioaddr + AST_ETHER_PHYCR);
+
+	ast_ether_phy_rw_waiting(ioaddr);
+}
+
+static void ast_ether_enable_expand_regs_and_clk(struct net_device* dev)
+{
+	struct ast_ether_priv *priv = netdev_priv(dev);
+	u32 reg_val = 0x00;
+
+	switch (priv->phy_oui) 
+	{
+		case MARVELL_88E1111_OUI:
+		case BROADCOM_BCM5221_OUI:
+		case BROADCOM_BCM5241_OUI:
+		case MICREL_KSZ80X1_OUI:
+		case REALTEK_RTL82X1X_OUI:
+			break;
+		case BROADCOM_BCM5421_OUI:
+		case BROADCOM_BCM5461_OUI:
+		case BROADCOM_BCM54612E_OUI:
+			/* enable expand reg and CLK125 */
+			ast_ether_phy_write_register(dev, priv->phy_addr, 0x17, 0xd34);
+			reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, 0x15);
+			reg_val |= 0x02;
+			ast_ether_phy_write_register(dev, priv->phy_addr, 0x15, reg_val);
+			ast_ether_phy_write_register(dev, priv->phy_addr, 0x17, 0x0);
+			ast_ether_phy_write_register(dev, priv->phy_addr, 0x1C, 0x8c00);
+			ast_ether_phy_write_register(dev, priv->phy_addr, 0x18, 0xf0e7);
+			break;
+		default:
+			priv->phy_oui = 0; /* not supported PHY or NC-SI */
+			break;
+	}
+
+	return;
+}
+
+/* read OUI and Model of PHY */
+static void ast_ether_read_phy_id(struct net_device* dev)
+{
+	struct ast_ether_priv *priv = netdev_priv(dev);
+	u32 reg_val;
+	int i, ret1, ret2;
+
+	for(i = 0 ; i < 32 ; i++){
+		ret1 = ast_ether_phy_read_register(dev, i, PHY_COM_REG_ADDR_ID_HI);
+		ret2 = ast_ether_phy_read_register(dev, i, PHY_COM_REG_ADDR_ID_LO);
+		if( ret1 != 0xffff && ret2 != 0xffff ){
+			priv->phy_addr = i;
+			break;
+		}
+	}
+
+	/* OUI[23:22] are not represented in PHY ID registers */
+	reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, PHY_COM_REG_ADDR_ID_HI);
+	priv->phy_oui = (reg_val & 0xFFFF) << 6; /* OUI[21:6] in ID_HI[15:0] */
+
+	reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, PHY_COM_REG_ADDR_ID_LO);
+	priv->phy_oui |= (reg_val & 0xFFFF) >> 10; /* OUI[5:0] in ID_LO[15:10] */
+
+	priv->phy_model = (reg_val & 0x03F0) >> 4; /* MODEL[5:0] in ID_LO[9:4] */
+
+	priv->phy_rev = (reg_val & 0x000F); /* Revision[5:0] in ID_LO[3:0] */
+
+	ast_ether_enable_expand_regs_and_clk(dev);
+}
+
+/**
+ * ast_mii_check_gmii_support (origin from mii_check_gmii_support) - check if the MII supports Gb interfaces 
+ * @dev: the net interface
+ */  
+int ast_mii_check_gmii_support(struct net_device *dev)                                                                                                     
+{        
+    struct ast_ether_priv *priv = netdev_priv(dev);
+    uint32_t reg = 0;
+    reg = ast_ether_phy_read_register(dev, priv->phy_addr, MII_BMSR);
+
+    if (reg & BMSR_ESTATEN) {
+        reg = ast_ether_phy_read_register(dev, priv->phy_addr, MII_ESTATUS);
+        if (reg & (ESTATUS_1000_TFULL | ESTATUS_1000_THALF))
+            return 1; 
+    }
+
+    return 0;
+}  
+
+/* Configures the PHY to restart Auto-Negotiation. */
+void ast_ether_phy_restart_auto_neg(struct net_device* dev)
+{
+	struct ast_ether_priv *priv = netdev_priv(dev);
+	u16 reg_val;
+
+	/* restart auto-negotiation */
+	reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, PHY_COM_REG_ADDR_CONTROL);
+	reg_val |= PHY_COM_REG_CONTROL_RE_AUTO;
+	ast_ether_phy_write_register(dev, priv->phy_addr, PHY_COM_REG_ADDR_CONTROL, reg_val);
+
+	/* Waiting for complete Auto-Negotiation */
+	while ((ast_ether_phy_read_register(dev, priv->phy_addr, PHY_COM_REG_ADDR_STATUS) & PHY_COM_REG_STATUS_AUTO_OK) == 0)
+		mdelay(2);
+}
+
+static void ast_ether_set_link_status(struct net_device* dev)
+{
+	struct ast_ether_priv *priv = netdev_priv(dev);
+	unsigned int ioaddr = dev->base_addr;
+	unsigned int reg_val=0, duplex=0, speed=0;
+
+	if (priv->phy_oui != 0) {
+		reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, PHY_COM_REG_ADDR_STATUS);
+		if (reg_val & PHY_COM_REG_STATUS_LINK) {
+            if (rtnl_trylock())
+            {
+				if(priv->link_state != 1)
+				{
+					//netdev_link_up(dev);
+					priv->link_state = 1;
+				}
+                rtnl_unlock();
+            }
+            else
+            {
+				if(priv->link_state != 1)
+				{
+					//netdev_link_up(dev);
+					priv->link_state = 1;
+				}
+            }
+			/* read speed and duplex from PHY */
+			switch (priv->phy_oui) {
+			case MARVELL_88E1111_OUI:
+				reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, MARVELL_88E1111_REG_ADDR_PHY_STATUS);
+				duplex = (reg_val & MARVELL_88E1111_REG_PHY_STATUS_DUPLEX_MASK) >> 13;
+				speed = (reg_val & MARVELL_88E1111_REG_PHY_STATUS_SPEED_MASK) >> 14;
+				break;
+			case BROADCOM_BCM5221_OUI:
+			case BROADCOM_BCM5241_OUI:
+				reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, BROADCOM_BCM5221_REG_ADDR_AUX_CTRL_STAT);
+				duplex = (reg_val & BROADCOM_BCM5221_REG_AUX_CTRL_STAT_DEPLEX) ? PHY_DUPLEX_FULL : PHY_DUPLEX_HALF;
+				speed = (reg_val & BROADCOM_BCM5221_REG_AUX_CTRL_STAT_SPEED) ? PHY_SPEED_100M : PHY_SPEED_10M;
+				break;
+			case BROADCOM_BCM5461_OUI:
+			case BROADCOM_BCM54612E_OUI:
+			case BROADCOM_BCM5421_OUI:
+            	reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, 0x1C); 
+            	if ((reg_val & 0x7c00) != 0x2000) 
+            	{ 
+            		ast_ether_phy_write_register(dev, priv->phy_addr, 0x1C, 0x2000); 
+            		reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, 0x1C); 
+            	} 
+            	if ((reg_val & 0x0080) != 0) 
+            		duplex = PHY_DUPLEX_HALF; 
+            	else 
+            		duplex = PHY_DUPLEX_FULL; 
+
+            	if ((reg_val & 0x0018) == 0)  
+            		speed = PHY_SPEED_1000M; 
+            	else 
+            		if ((reg_val & 0x0018) == 0x0010)  
+            			speed = PHY_SPEED_10M; 
+            		else 
+            			speed = PHY_SPEED_100M; 
+            	break; 
+			case REALTEK_RTL82X1X_OUI:
+				switch (priv->phy_model) {
+				case 0x01:
+					reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, PHY_COM_REG_ADDR_CONTROL);
+					duplex = (reg_val & PHY_COM_REG_CONTROL_DUPLEX) ? PHY_DUPLEX_FULL : PHY_DUPLEX_HALF;
+					speed = (reg_val & PHY_COM_REG_CONTROL_SPEED) ? PHY_SPEED_100M : PHY_SPEED_10M;
+					break;
+				case 0x11:
+					if(priv->phy_rev == 0x06) {
+						reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, REALTEK_RTL8211F_REG_ADDR_PHY_STAT);
+						duplex = (reg_val & REALTEK_RTL8211F_REG_ADDR_PHY_STS_DEPLEX) ? PHY_DUPLEX_FULL : PHY_DUPLEX_HALF;
+						speed = (reg_val & REALTEK_RTL8211F_REG_ADDR_PHY_STS_SPEED_MASK) >> REALTEK_RTL8211F_REG_ADDR_PHY_STS_SPEED_SHIFT;
+					} else {
+						reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, REALTEK_RTL8211B_REG_ADDR_PHY_STAT);
+						duplex = (reg_val & REALTEK_RTL8211B_REG_ADDR_PHY_STS_DEPLEX) ? PHY_DUPLEX_FULL : PHY_DUPLEX_HALF;
+						speed = (reg_val & REALTEK_RTL8211B_REG_ADDR_PHY_STS_SPEED_MASK) >> REALTEK_RTL8211B_REG_ADDR_PHY_STS_SPEED_SHIFT;
+					}
+					break;
+				default:
+					speed = PHY_SPEED_100M;
+					duplex = 1;
+				}
+				break;
+			case MICREL_KSZ80X1_OUI:
+				switch (priv->phy_model) {
+				case 0x11://8041
+					reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, MICREL_KSZ8041_REG_STATUS);
+					reg_val = (reg_val & MICREL_KSZ8041_REG_STATUS_MASK) >> MICREL_KSZ8041_REG_STATUS_SHIFT;
+					switch (reg_val) {
+					case MICREL_KSZ8041_REG_STATUS_HALF_10:
+						duplex = PHY_DUPLEX_HALF;
+						speed = PHY_SPEED_10M;
+						break;
+					case MICREL_KSZ8041_REG_STATUS_HALF_100:
+						duplex = PHY_DUPLEX_HALF;
+						speed = PHY_SPEED_100M;
+						break;
+					case MICREL_KSZ8041_REG_STATUS_FULL_10:
+						duplex = PHY_DUPLEX_FULL;
+						speed = PHY_SPEED_10M;
+						break;
+					case MICREL_KSZ8041_REG_STATUS_FULL_100:
+						duplex = PHY_DUPLEX_FULL;
+						speed = PHY_SPEED_100M;
+						break;
+					default:
+						duplex = PHY_DUPLEX_FULL;
+						speed = PHY_SPEED_100M;
+						break;
+					}
+					break;
+				case 0x15://8031
+					reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, MICREL_KSZ8031_REG_STATUS);
+					reg_val = reg_val & MICREL_KSZ8031_REG_STATUS_MASK;
+					switch (reg_val) {
+					case MICREL_KSZ8041_REG_STATUS_HALF_10:
+						duplex = PHY_DUPLEX_HALF;
+						speed = PHY_SPEED_10M;
+						break;
+					case MICREL_KSZ8041_REG_STATUS_HALF_100:
+						duplex = PHY_DUPLEX_HALF;
+						speed = PHY_SPEED_100M;
+						break;
+					case MICREL_KSZ8041_REG_STATUS_FULL_10:
+						duplex = PHY_DUPLEX_FULL;
+						speed = PHY_SPEED_10M;
+						break;
+					case MICREL_KSZ8041_REG_STATUS_FULL_100:
+						duplex = PHY_DUPLEX_FULL;
+						speed = PHY_SPEED_100M;
+						break;
+					default:
+						duplex = PHY_DUPLEX_FULL;
+						speed = PHY_SPEED_100M;
+						break;
+					}
+					break;
+				case 0x22://9031
+					reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, MICREL_KSZ9031_REG_STATUS);
+					if(reg_val & (1 << 6)) 
+						speed = PHY_SPEED_1000M;
+					else if(reg_val & (1 << 5))
+						speed = PHY_SPEED_100M;
+					else 
+						speed = PHY_SPEED_10M;
+					
+					if(reg_val & (1 << 3))
+						duplex = PHY_DUPLEX_FULL;
+					else
+						duplex = PHY_DUPLEX_HALF;
+					break;
+				default:
+					reg_val = 0;
+					break;
+				}
+				break;
+			default:
+				speed = PHY_SPEED_100M;
+				duplex = 1;
+				break;
+			}
+			netif_carrier_on(dev);
+		} else { /* link is down */
+            if (rtnl_trylock())
+            {
+				if(priv->link_state != 0)
+				{
+					//netdev_link_down(dev);
+					priv->link_state = 0;
+				}
+                rtnl_unlock();
+            }
+            else
+            {
+				if(priv->link_state != 0)
+				{
+					//netdev_link_down(dev);
+					priv->link_state = 0;
+				}
+            }
+			/* default setting: 100M, duplex */
+			speed = PHY_SPEED_100M;
+			duplex = 1;
+			netif_carrier_off(dev);
+		}
+	} else { /* not support PHY of NC-SI */
+		/* default setting: 100M, duplex */
+		speed = PHY_SPEED_100M;
+		duplex = 1;
+		//netif_carrier_on(dev);
+	}
+
+	reg_val = inl(ioaddr + AST_ETHER_MACCR);
+
+	/* set speed */
+	if (speed == PHY_SPEED_1000M) { /* 1000 Mbps */
+		priv->maccr |= (MACCR_GMAC_MODE | MACCR_SPEED_100);
+		reg_val |= (MACCR_GMAC_MODE | MACCR_SPEED_100);
+	} else { /* 10/100 Mbps */
+		reg_val &= ~(MACCR_GMAC_MODE | MACCR_SPEED_100);
+		priv->maccr &= ~(MACCR_GMAC_MODE | MACCR_SPEED_100);
+
+		if (speed == PHY_SPEED_100M) {
+			reg_val |= MACCR_SPEED_100;
+			priv->maccr |= MACCR_SPEED_100;
+		}
+	}
+
+	/* set duplex */
+	if (duplex == PHY_DUPLEX_FULL) {
+		priv->maccr |= MACCR_FULLDUP;
+		reg_val |= MACCR_FULLDUP;
+	} else {
+		priv->maccr &= ~MACCR_FULLDUP;
+		reg_val &= ~MACCR_FULLDUP;
+	}
+
+	outl(reg_val, ioaddr + AST_ETHER_MACCR);
+}
+
+#ifdef BROADCAST_BLACKLIST
+static void ast_ether_bc_checker(unsigned long data)
+{
+	struct net_device *dev;
+	struct ast_ether_priv *priv;
+	unsigned int reg_value ;
+	unsigned int ioaddr;
+
+	dev = (struct net_device *) data;
+	ioaddr = dev->base_addr;
+	priv = netdev_priv(dev);
+
+	if( ast_ether_bc[priv->idx].bc_ctr ){
+		ast_ether_bc[priv->idx].bc_count = 0 ;  
+		ast_ether_bc[priv->idx].bc_ctr = 0 ;
+		reg_value = inl(ioaddr + AST_ETHER_IER);
+		reg_value |= (ISR_RPKT2B) ;
+		outl(reg_value, ioaddr + AST_ETHER_IER);
+	}
+	else
+		ast_ether_bc[priv->idx].bc_count = 0 ;
+
+	ast_ether_bc[priv->idx].timer.expires = jiffies + (AST_BC_CHECK_INTERVAL * HZ);
+	add_timer(&ast_ether_bc[priv->idx].timer);
+}
+#endif
+
+static void ast_ether_phy_status_checker(unsigned long data)
+{
+	struct net_device *dev;
+	struct ast_ether_priv *priv;
+
+	dev = (struct net_device *) data;
+	priv = netdev_priv(dev);
+
+	ast_ether_set_link_status(dev);
+
+	priv->timer.expires = jiffies + (AST_PHY_STATUS_CHECK_INTERVAL * HZ);
+	add_timer(&priv->timer);
+}
+
+/* allocates memory for Tx/Rx descriptors, we use ring structure(AST2100 does not support chain structure) */
+static void ast_ether_alloc_descriptor(struct net_device *dev)
+{
+	struct ast_ether_priv *priv = netdev_priv(dev);
+
+	/* allocate Rx descriptors */
+	priv->rx_desc = dma_alloc_coherent(NULL, sizeof(struct ast_eth_desc) * RX_DES_NUM, &priv->rx_desc_dma, GFP_KERNEL);
+	if (priv->rx_desc == NULL) {
+		printk(KERN_ERR "%s: allocate Rx descriptor failed.\n", dev->name);
+	}
+	memset(priv->rx_desc, 0, sizeof(struct ast_eth_desc) * RX_DES_NUM);
+
+	/* allocate Tx descriptors */
+	priv->tx_desc = dma_alloc_coherent(NULL, sizeof(struct ast_eth_desc) * TX_DES_NUM, &priv->tx_desc_dma, GFP_KERNEL);
+	if (priv->tx_desc == NULL) {
+		printk(KERN_ERR "%s: allocate Tx descriptor failed.\n", dev->name);
+	}
+	memset(priv->tx_desc, 0, sizeof(struct ast_eth_desc) * TX_DES_NUM);
+}
+
+static void ast_ether_init_descriptor(struct net_device *dev)
+{
+	struct ast_ether_priv *priv = netdev_priv(dev);
+	int i;
+
+	/* initializes Rx descriptors */
+	priv->cur_rx = 0;
+	priv->dirty_rx = 0;
+	/* allocate Rx buffers */
+	for (i = 0; i < RX_DES_NUM; i ++) {
+        struct sk_buff *rx_skbuff = priv->rx_skbuff[i];
+        if (rx_skbuff == NULL) {
+            if (!(rx_skbuff = priv->rx_skbuff[i] = dev_alloc_skb (RX_BUF_SIZE + 16))) {
+                printk(KERN_ERR "%s: allocate Rx buffer failed.\n", dev->name);
+                ast_ether_free_rx_buf(dev);
+                return;
+            }
+            rx_skbuff->dev = dev; /* Mark as being used by this device. */
+            skb_reserve(rx_skbuff, NET_IP_ALIGN); /* 16 byte align the IP header. */
+        }
+        
+        rmb();
+		priv->rx_skb_dma[i] = dma_map_single(NULL, rx_skbuff->data, RX_BUF_SIZE, DMA_FROM_DEVICE);
+		priv->rx_desc[i].buffer = priv->rx_skb_dma[i];
+        wmb();
+        priv->rx_desc[i].status &= ~RX_DESC_RXPKT_RDY; /* haredware owns descriptor */
+	}
+
+	priv->rx_desc[RX_DES_NUM - 1].status |= RX_DESC_EDORR; /* last descriptor */
+
+	/* initializes Tx descriptors */
+	priv->cur_tx = 0;
+	priv->dirty_tx = 0;
+	for (i = 0; i < TX_DES_NUM; i ++) {
+		priv->tx_desc[i].status &= ~TX_DESC_TXDMA_OWN; /* software owns descriptor */
+		priv->tx_skbuff[i] = NULL;
+		priv->tx_skb_dma[i] = 0;
+	}
+	priv->tx_desc[TX_DES_NUM - 1].status |= TX_DESC_EDOTR; /* last descriptor */
+}
+
+static void ast_ether_up(struct net_device *dev)
+{
+	struct ast_ether_priv *priv = netdev_priv(dev);
+	unsigned int ioaddr = dev->base_addr;
+	unsigned int reg_value;
+	unsigned int rfifo_rsize;
+	unsigned int tfifo_rsize;
+	u32 hardware_addr;
+	int i;
+
+	/* software reset */
+	outl(MACCR_SW_RST, ioaddr + AST_ETHER_MACCR);
+
+	/* wait SW_RST bit to be auto cleared */
+	while ((inl(ioaddr + AST_ETHER_MACCR) & MACCR_SW_RST) != 0)
+		mdelay(10);
+
+	outl(0, ioaddr + AST_ETHER_IER); /* Disable all interrupts */
+
+	/* reset Rx descriptors */
+	priv->cur_rx = 0;
+	priv->dirty_rx = 0;
+	for (i = 0; i < RX_DES_NUM; i ++) {
+		priv->rx_desc[i].status &= ~RX_DESC_RXPKT_RDY; /* haredware owns descriptor */
+	}
+
+	/* reset Tx descriptors */
+	priv->cur_tx = 0;
+	priv->dirty_tx = 0;
+	for (i = 0; i < TX_DES_NUM; i ++) {
+		priv->tx_desc[i].status &= ~TX_DESC_TXDMA_OWN; /* software owns descriptor */
+		priv->tx_skbuff[i] = NULL;
+		priv->tx_skb_dma[i] = 0;
+	}
+
+	/* set the MAC address */
+	hardware_addr = ((u32)dev->dev_addr[0]) << 8 | (u32)dev->dev_addr[1];
+	outl(hardware_addr, ioaddr + AST_ETHER_MAC_MADR);
+
+	hardware_addr = 0;
+	for (i = 0; i < 4; i ++)
+		hardware_addr |= ((u32)(dev->dev_addr[i + 2])) << (8 * (4 - 1 - i));
+	outl(hardware_addr, ioaddr + AST_ETHER_MAC_LADR);
+
+	/* hardware works with bus address */
+	outl(priv->rx_desc_dma, ioaddr + AST_ETHER_RXR_BADR);
+	outl(priv->tx_desc_dma, ioaddr + AST_ETHER_TXR_BADR);
+
+	/* set interrupt timer */
+	reg_value = (((1 << ITCR_TXINT_THR_SHIFT) & ITCR_TXINT_THR_MASK) |
+				((0 << ITCR_TXINT_CNT_SHIFT) & ITCR_TXINT_CNT_MASK) |
+				((1 << ITCR_RXINT_THR_SHIFT) & ITCR_RXINT_THR_MASK) |
+				((0 << ITCR_RXINT_CNT_SHIFT) & ITCR_RXINT_CNT_MASK));
+	outl(reg_value, ioaddr + AST_ETHER_ITC);
+
+	/* set automatic polling timer */
+	reg_value = (((0 << APTC_TXPOLL_CNT_SHIFT) & APTC_TXPOLL_CNT_MASK) | 
+				((1 << APTC_RXPOLL_CNT_SHIFT) & APTC_RXPOLL_CNT_MASK));
+	outl(reg_value, ioaddr + AST_ETHER_APTC);
+	
+	/* set Tx/Rx descriptor size, max size of DMA burst, Rx FIOF hish/low threshold */
+	outl(0x00022F72, ioaddr + AST_ETHER_DBLAC);
+	/*Flow control enable*/
+	reg_value=inl(ioaddr + AST_ETHER_FCR);
+	reg_value |= 0xffff0805;
+	outl(reg_value, ioaddr + AST_ETHER_FCR);
+
+	/* read hardware FIFO size */
+	reg_value = inl(ioaddr + AST_ETHER_FEAR);
+	rfifo_rsize = (reg_value & FEAR_RFIFO_RSIZE_MASK) >> FEAR_RFIFO_RSIZE_SHIFT;
+	tfifo_rsize = (reg_value & FEAR_TFIFO_RSIZE_MASK) >> FEAR_TFIFO_RSIZE_SHIFT;
+
+	/* set Tx/Rx FIFO size and Tx priority threshold */
+	reg_value = inl(ioaddr + AST_ETHER_TPAFCR);
+	reg_value &= ~(FPAFCR_TFIFO_SIZE_MASK | FPAFCR_RFIFO_SIZE_MASK);
+	reg_value |= (tfifo_rsize << FPAFCR_TFIFO_SIZE_SHIFT);
+	reg_value |= (rfifo_rsize << FPAFCR_RFIFO_SIZE_SHIFT);
+	outl(reg_value, ioaddr + AST_ETHER_TPAFCR);
+
+	/* set rx buffer size */
+	outl(RX_BUF_SIZE & RBSR_MASK, ioaddr + AST_ETHER_RBSR);
+
+	/* enable interrupts */
+	reg_value = ISR_AHB_ERR | ISR_TPKT_LOST | ISR_TPKT2E | ISR_RPKT_LOST | ISR_RXBUF_UNAVA | ISR_RPKT2B;
+	if (priv->phy_oui != 0) {
+		if(priv->timer.function != NULL)
+			del_timer_sync(&priv->timer);
+		init_timer(&priv->timer);
+		priv->timer.data = (unsigned long) dev;
+		priv->timer.function = ast_ether_phy_status_checker;
+		priv->timer.expires = jiffies + (AST_PHY_STATUS_CHECK_INTERVAL * HZ);
+		add_timer(&priv->timer);
+	}
+	
+#ifdef BROADCAST_BLACKLIST
+	ast_ether_bc[priv->idx].bc_count = 0 ;	
+	ast_ether_bc[priv->idx].bc_ctr = 0 ;
+	ast_ether_bc[priv->idx].trans_busy_1 = 0 ; 
+	ast_ether_bc[priv->idx].trans_busy_2 = 0 ; 
+
+	init_timer(&ast_ether_bc[priv->idx].timer);
+	ast_ether_bc[priv->idx].timer.data = (unsigned long) dev;
+	ast_ether_bc[priv->idx].timer.function = ast_ether_bc_checker;
+	ast_ether_bc[priv->idx].timer.expires = jiffies + (AST_BC_CHECK_INTERVAL * HZ);
+	add_timer(&ast_ether_bc[priv->idx].timer);
+#endif
+	outl(reg_value, ioaddr + AST_ETHER_IER);
+
+	/* enable trans/recv, ... */
+	outl(priv->maccr, ioaddr + AST_ETHER_MACCR);
+}
+
+static void ast_ether_down(unsigned int ioaddr)
+{
+	outl(0, ioaddr + AST_ETHER_IER); /* Disables all interrupts */
+	outl(0, ioaddr + AST_ETHER_MACCR); /* Disables trans/recv, ... */
+}
+
+static int ast_ether_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ast_ether_priv *priv = netdev_priv(dev);
+	volatile struct ast_eth_desc *cur_desc;
+	int entry;
+	int length;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	/* Note: the chip doesn't have auto-pad! */
+	length = skb->len;
+	if (length < ETH_ZLEN) {
+		if (skb_padto(skb, ETH_ZLEN) < 0) {
+			priv->stats.tx_dropped ++;
+			spin_unlock_irqrestore(&priv->lock, flags);
+			return 0;
+		}
+		length = ETH_ZLEN;
+	}
+
+	entry = priv->cur_tx & (TX_DES_NUM - 1);
+	cur_desc = &priv->tx_desc[entry];
+
+	if (cur_desc->status & TX_DESC_TXDMA_OWN) {
+		netif_stop_queue(dev);
+		priv->stats.tx_dropped ++;
+		spin_unlock_irqrestore(&priv->lock, flags);
+		return 1;
+	}
+
+	priv->tx_skbuff[entry] = skb;
+	priv->tx_skb_dma[entry] = dma_map_single(NULL, skb->data, length, DMA_TO_DEVICE);
+
+	cur_desc->buffer = priv->tx_skb_dma[entry];
+	cur_desc->status &= ~(TX_DESC_TXBUF_SIZE | TX_DESC_CRC_ERR);
+	cur_desc->status |= (length | TX_DESC_LTS | TX_DESC_FTS | TX_DESC_TXDMA_OWN);
+
+	dev->trans_start = jiffies;
+	priv->cur_tx ++;
+
+	wmb();
+	outl(0xffffffff, dev->base_addr + AST_ETHER_TXPD); /* Trigger an Tx Poll demand */
+
+	if (priv->cur_tx == (priv->dirty_tx + TX_DES_NUM)) { /* Tx ring is full */
+		netif_stop_queue(dev);
+	}
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+
+static void ast_ether_free_tx_buf(struct net_device *dev)
+{
+	struct ast_ether_priv *priv = netdev_priv(dev);
+	int entry;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	/* Free used tx sk_buffs */
+	while (priv->dirty_tx != priv->cur_tx) {
+		entry = priv->dirty_tx & (TX_DES_NUM - 1);
+		if (priv->tx_desc[entry].status & TX_DESC_TXDMA_OWN)
+			break;
+		priv->stats.tx_bytes += priv->tx_skbuff[entry]->len;
+		dma_unmap_single(NULL, priv->tx_skb_dma[entry], priv->tx_skbuff[entry]->len, DMA_TO_DEVICE);
+		dev_kfree_skb_irq(priv->tx_skbuff[entry]);
+		priv->tx_skbuff[entry] = NULL;
+		priv->tx_skb_dma[entry] = 0;
+		priv->dirty_tx ++;
+	}
+
+	if (netif_queue_stopped(dev) && (priv->cur_tx != (priv->dirty_tx + TX_DES_NUM)))
+		netif_wake_queue(dev);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static void ast_ether_realloc_rx_buf(struct net_device *dev)
+{
+	struct ast_ether_priv *priv = netdev_priv(dev);
+	struct sk_buff *skb;
+	int entry;
+
+	/* Reallocate the Rx ring buffers. */
+	while (priv->dirty_rx != priv->cur_rx) {
+		entry = priv->dirty_rx & (RX_DES_NUM - 1);
+		if (priv->rx_skbuff[entry] == NULL) {
+			skb = dev_alloc_skb(RX_BUF_SIZE + 16);
+			priv->rx_skbuff[entry] = skb;
+			if (skb == NULL) {
+				printk(KERN_ERR "%s: reallocate Rx buffer failed.\n", dev->name);
+                ast_ether_free_rx_buf(dev);
+                return;
+			}
+
+			skb->dev = dev; /* Mark as being used by this device. */
+			skb_reserve(skb, NET_IP_ALIGN); /* 16 byte align the IP header. */
+
+			priv->rx_skb_dma[entry] = dma_map_single(NULL, skb->data, RX_BUF_SIZE, DMA_FROM_DEVICE);
+			priv->rx_desc[entry].buffer = priv->rx_skb_dma[entry];
+			wmb();
+			priv->rx_desc[entry].status &= RX_DESC_EDORR; /* clear all field except EDORR, return ownership to hardware */
+		}
+		priv->dirty_rx ++;
+	}
+}
+
+static void ast_ether_free_rx_buf(struct net_device *dev)
+{
+	struct ast_ether_priv *priv = netdev_priv(dev);
+	int i;
+
+	/* free all allocated skbuffs */
+    priv->cur_rx = 0;
+	priv->dirty_rx = 0;
+	for (i = 0; i < RX_DES_NUM; i++) {
+		priv->rx_desc[i].status = 0;
+		wmb();		/* Make sure adapter sees owner change */
+		if (priv->rx_skbuff[i]) {
+            dma_unmap_single(NULL, priv->rx_skb_dma[i], priv->rx_skbuff[i]->len, DMA_TO_DEVICE);
+            dev_kfree_skb_irq(priv->rx_skbuff[i]);
+
+		}
+		priv->rx_skbuff[i] = NULL;
+		priv->rx_skb_dma[i] = 0;
+	}
+}
+
+
+static inline void ast_ether_rx_csum(struct sk_buff *skb, struct ast_eth_desc *desc)
+{
+	u32 status = desc->vlan;
+	u32 protocol_type = status & RX_DESC_PROTL_TYPE_MASK;
+
+	///Checking IP protcol here allowing the invalid ICMP checksum packets hence check is removed
+	if (((protocol_type == RX_DESC_PROTL_TYPE_UDP) && !(status & RX_DESC_UDPCS_FAIL)) ||
+		((protocol_type == RX_DESC_PROTL_TYPE_TCP) && !(status & RX_DESC_TCPCS_FAIL)))
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+	else
+		skb->ip_summed = CHECKSUM_NONE;
+}
+
+static void ast_ether_rx(struct net_device *dev)
+{
+	struct ast_ether_priv *priv = netdev_priv(dev);
+	struct sk_buff *skb;
+	u32 status;
+	int pkt_len;
+	int has_error;
+	int has_first;
+	int entry;
+#ifdef BROADCAST_BLACKLIST
+	unsigned int ioaddr = dev->base_addr;
+	unsigned int reg_value;
+#endif
+
+	has_error = 0;
+	has_first = 0;
+
+	while ((priv->dirty_rx + RX_DES_NUM) != priv->cur_rx) {
+		entry = priv->cur_rx & (RX_DES_NUM - 1);
+		status = priv->rx_desc[entry].status;
+		if (!(status & RX_DESC_RXPKT_RDY)) /* owned by hardware */
+            break;
+
+		if (status & RX_DESC_FRS) { /* first frame of packet, check error */
+			has_first = 1;
+
+			if (status & (RX_DESC_CRC_ERR | RX_DESC_FTL | RX_DESC_RUNT | RX_DESC_RX_ODD_NB | RX_DESC_FIFO_FULL)) { /* There was an error. */
+				priv->stats.rx_errors ++;
+				has_error = 1;
+			}
+
+			if (status & RX_DESC_MULTICAST)
+				priv->stats.multicast ++;
+			
+#ifdef BROADCAST_BLACKLIST
+#ifndef CONFIG_ASTMAC100_NAPI
+			if ((status & RX_DESC_BROADCAST)||(status & RX_DESC_MULTICAST)){
+				if( !ast_ether_bc[priv->idx].bc_ctr ){
+					ast_ether_bc[priv->idx].bc_count++;
+					if (ast_ether_bc[priv->idx].bc_count >= 1000) {
+						reg_value = inl(ioaddr + AST_ETHER_IER);
+						reg_value &= ~(ISR_RPKT2B) ;
+						outl(reg_value, ioaddr + AST_ETHER_IER);
+						ast_ether_bc[priv->idx].bc_ctr = 1 ;
+					}
+				}
+			}
+#endif
+#endif
+		}
+
+		skb = priv->rx_skbuff[entry];
+		dma_unmap_single(NULL, priv->rx_skb_dma[entry], RX_BUF_SIZE, DMA_FROM_DEVICE);
+		priv->rx_skbuff[entry] = NULL;
+		priv->rx_skb_dma[entry] = 0;
+
+		if (has_error) {
+			if (status & RX_DESC_CRC_ERR)
+				priv->stats.rx_crc_errors ++;
+			if (status & RX_DESC_FIFO_FULL)
+				priv->stats.rx_fifo_errors ++;
+			kfree_skb(skb);
+		} else {
+			pkt_len = (status & RX_DESC_VDBC) - 4; /* Omit the four octet CRC from the length. */
+			if (pkt_len > 1518) {
+				printk(KERN_WARNING "%s: Bogus packet size of %d (%#x).\n", dev->name, pkt_len, pkt_len);
+				pkt_len = 1518;
+				priv->stats.rx_length_errors ++;
+			}
+
+			ast_ether_rx_csum(skb, &priv->rx_desc[entry]);
+			skb_put(skb, pkt_len); /* reflect the DMA operation result */
+			skb->protocol = eth_type_trans(skb, dev);
+
+#ifdef CONFIG_ASTMAC100_NAPI
+			netif_receive_skb(skb);
+#else
+			netif_rx(skb);
+#endif
+	
+			dev->last_rx = jiffies;
+			priv->stats.rx_packets ++;
+			priv->stats.rx_bytes += pkt_len;
+		}
+
+		priv->cur_rx ++;
+	}
+	
+#ifdef BROADCAST_BLACKLIST
+	if(ast_ether_bc[priv->idx].trans_busy_1 == 1){
+		reg_value = inl(ioaddr + AST_ETHER_IER);
+		reg_value |= ISR_RXBUF_UNAVA ;
+		outl(reg_value, ioaddr + AST_ETHER_IER);
+	}
+
+	if(ast_ether_bc[priv->idx].trans_busy_2 == 1){
+		reg_value = inl(ioaddr + AST_ETHER_IER);
+		reg_value |= ISR_RPKT_LOST ;
+		outl(reg_value, ioaddr + AST_ETHER_IER);
+	} 
+#endif
+}
+
+#ifdef CONFIG_ASTMAC100_NAPI
+static int ast_ether_poll(struct napi_struct *napi,int budget)
+{
+       struct ast_ether_priv *priv = container_of(napi, struct ast_ether_priv, napi);
+       struct net_device *dev = priv->dev;
+       unsigned int tmp = 0;
+       int i = 0;
+
+       for(i=0;i<budget;i++) {
+               ast_ether_rx(dev);
+               ast_ether_realloc_rx_buf(dev);
+       }
+       netif_rx_complete(dev, napi);
+       tmp = inl( dev->base_addr + AST_ETHER_IER );
+       outl((tmp | ISR_RPKT2B), dev->base_addr + AST_ETHER_IER);
+       return 0;
+}
+#endif
+
+static irqreturn_t ast_ether_irq_handler(int irq, void *dev_id)
+{
+	struct net_device *dev;
+	struct ast_ether_priv *priv;
+	unsigned int ioaddr;
+	unsigned int intr_mask;
+	unsigned int status;
+	unsigned int reg_value;
+
+	dev = (struct net_device *)dev_id;
+	priv = netdev_priv(dev);
+	ioaddr = dev->base_addr;
+
+	intr_mask = inl(ioaddr + AST_ETHER_IER);
+	status = inl(ioaddr + AST_ETHER_ISR) & intr_mask;
+	outl(status, ioaddr + AST_ETHER_ISR); /* write to clear */
+
+	if (status & ISR_PHYSTS_CHG) { /* PHY status change */
+		printk("ISR_PHYSTS_CHG\n");
+	}
+
+	if (status & ISR_RPKT2B) { /* Rx completed */
+#ifdef CONFIG_ASTMAC100_NAPI
+               outl (intr_mask & ~(ISR_RPKT2B), ioaddr + AST_ETHER_IER);
+               if (likely(netif_rx_schedule_prep(dev, &priv->napi)))
+                       __netif_rx_schedule(dev, &priv->napi);
+#else
+		ast_ether_rx(dev);
+		ast_ether_realloc_rx_buf(dev);
+#endif
+	}
+
+	if (status & ISR_RXBUF_UNAVA){
+		reg_value = inl(ioaddr + AST_ETHER_IER);
+		reg_value &= ~(ISR_RXBUF_UNAVA);
+		outl(reg_value, ioaddr + AST_ETHER_IER);
+#ifdef BROADCAST_BLACKLIST
+		ast_ether_bc[priv->idx].trans_busy_1 = 1 ;
+#endif
+	}
+	if (status & ISR_RPKT_LOST){
+		reg_value = inl(ioaddr + AST_ETHER_IER);
+		reg_value &= ~(ISR_RPKT_LOST);
+		outl(reg_value, ioaddr + AST_ETHER_IER);
+#ifdef BROADCAST_BLACKLIST
+		ast_ether_bc[priv->idx].trans_busy_2 = 1 ;
+#endif
+	}
+	if (status & ISR_TPKT2E) { /* Tx completed */
+		priv->stats.tx_packets ++;
+		ast_ether_free_tx_buf(dev);
+	}
+
+	if (status & ISR_TPKT_LOST)
+		printk("ISR_TPKT_LOST\n");
+
+	if (status & ISR_AHB_ERR)
+		printk("AHB error\n");
+
+	return IRQ_HANDLED;
+}
+
+/* The kernel calls this function when someone wants to use the net_device, typically "ifconfig eth%d up". */
+static int ast_ether_open(struct net_device *dev)
+{
+	int err;
+	int dev_id;
+	struct ast_ether_priv *priv;
+
+	dev_id = dev->dev_id;
+
+	err = request_irq(dev->irq, ast_ether_irq_handler, IRQF_DISABLED, dev->name, dev);
+	if (err != 0) {
+		return err;
+    }
+
+	ast_ether_read_phy_id(dev);
+	ast_ether_set_link_status(dev);
+
+	ast_ether_init_descriptor(dev);
+	ast_ether_up(dev);
+
+	netif_start_queue(dev);
+
+
+    priv = netdev_priv(dev);
+#ifdef CONFIG_ASTMAC100_NAPI
+       napi_enable(&priv->napi); 
+#endif
+    priv->supports_gmii = ast_mii_check_gmii_support(dev);
+	return 0;
+}
+
+static int ast_ether_close(struct net_device *dev)
+{
+	int dev_id;
+	struct ast_ether_priv *priv;
+    unsigned long flags;
+
+	dev_id = dev->dev_id;
+	priv = netdev_priv(dev);
+
+#ifdef CONFIG_ASTMAC100_NAPI
+       napi_disable(&priv->napi);
+#endif
+	netif_stop_queue(dev);
+
+	ast_ether_down(dev->base_addr);
+
+	if (priv->timer.function != NULL)
+	    del_timer_sync(&priv->timer);
+	
+	init_timer(&priv->timer);
+	priv->timer.data = (unsigned long)dev;
+	priv->timer.function = ast_ether_phy_status_checker;
+	priv->timer.expires = jiffies + (AST_PHY_STATUS_CHECK_INTERVAL * HZ);
+	add_timer(&priv->timer);
+
+#ifdef BROADCAST_BLACKLIST
+	if( ast_ether_bc[priv->idx].timer.function != NULL )
+		del_timer_sync(&ast_ether_bc[priv->idx].timer);
+#endif
+
+	free_irq(dev->irq, dev);
+	spin_lock_irqsave(&priv->lock, flags);
+
+	ast_ether_free_rx_buf(dev);
+	ast_ether_free_tx_buf(dev);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+
+/* Called by the kernel to send a packet out into the void of the net. */
+static void ast_ether_timeout(struct net_device *dev)
+{
+	/* If we get here, some higher level has decided we are broken.
+	There should really be a "kick me" function call instead. */
+	printk(KERN_WARNING "%s: transmit timed out\n", dev->name);
+
+	/* "kick" the adaptor */
+	ast_ether_up(dev);
+
+	netif_wake_queue(dev);
+	dev->trans_start = jiffies;
+}
+
+static struct net_device_stats* ast_ether_get_stats(struct net_device *dev)
+{
+	struct ast_ether_priv *priv = netdev_priv(dev);
+
+	return &priv->stats;
+}
+#ifdef HAVE_MULTICAST
+static void ast_ether_set_multicast_list(struct net_device *dev)
+{
+	unsigned int ioaddr = dev->base_addr;
+	struct ast_ether_priv *priv = netdev_priv(dev);
+#if 1
+	struct dev_mc_list *cur_addr;
+	struct netdev_hw_addr* ha;
+//	char* baddr;
+#endif
+	spin_lock(&priv->lock);
+
+	priv->maccr &= ~(MACCR_RX_ALLADR | MACCR_RX_MULTIPKT_EN | MACCR_RX_MULTIPKT_EN);
+
+	if (dev->flags & IFF_PROMISC) {
+		priv->maccr |= MACCR_RX_ALLADR;
+	} else if (dev->flags & IFF_ALLMULTI) {
+		priv->maccr |= MACCR_RX_MULTIPKT_EN;
+	} 
+
+	if (netdev_mc_count(dev) && (dev->flags & IFF_MULTICAST)) {
+		priv->maccr |= MACCR_RX_HT_EN;
+
+		netdev_for_each_mc_addr(ha, dev) {
+//			baddr = ha->baddr;
+		}
+#if 0
+		for (cur_addr = dev->mc.list; cur_addr != NULL; cur_addr = cur_addr->next) {
+			/* use invert of bits[7:2] of ethernet crc(little endian) result as hash table index */
+			bit_nr = (~ether_crc_le(ETH_ALEN, cur_addr->dmi_addr) & 0x000000fc) >> 2;
+			hash_table[bit_nr >> 5] |= 1 << (bit_nr & 0x1f);
+		}
+#endif
+	}
+
+	/* set the hash table to filter out unwanted multicast packets before they take up memory. */
+//	outl(hash_table[0], ioaddr + AST_ETHER_MAHT0);
+//	outl(hash_table[1], ioaddr + AST_ETHER_MAHT1);
+
+	outl(priv->maccr, ioaddr + AST_ETHER_MACCR);
+	spin_unlock(&priv->lock);
+}
+#else
+
+static void ast_ether_set_multicast_list(struct net_device *dev)
+{
+	unsigned int ioaddr = dev->base_addr;
+	struct ast_ether_priv *priv = netdev_priv(dev);
+
+	if (dev->flags & IFF_PROMISC) {
+		priv->maccr |= MACCR_RX_ALLADR;
+	} else if (dev->flags & IFF_ALLMULTI) {
+		priv->maccr |= MACCR_RX_MULTIPKT_EN;
+	} 
+	outl(priv->maccr, ioaddr + AST_ETHER_MACCR);
+}	
+#endif
+static int ast_ether_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+    struct ast_ether_priv *priv = netdev_priv(dev);
+	uint32_t advert, bmcr, lpa, nego;
+	uint32_t advert2 = 0, bmcr2 = 0, lpa2 = 0;
+
+	ast_ether_read_phy_id(dev);
+	
+	cmd->phy_address = 0;
+	cmd->supported = (SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full | SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
+	     				SUPPORTED_Autoneg | SUPPORTED_TP | SUPPORTED_MII | SUPPORTED_Pause);
+	if (priv->supports_gmii)
+	    cmd->supported |= SUPPORTED_1000baseT_Full;   /* Only support 1G full-duplex in ast2400 */
+	                  
+	cmd->transceiver = XCVR_INTERNAL; /* only supports internal transceiver */
+	cmd->advertising = ADVERTISED_TP | ADVERTISED_MII;
+	advert = ast_ether_phy_read_register(dev, priv->phy_addr, MII_ADVERTISE);
+    if (priv->supports_gmii)
+        advert2 = ast_ether_phy_read_register(dev, priv->phy_addr, MII_CTRL1000);
+
+	if (advert & ADVERTISE_10HALF)
+		cmd->advertising |= ADVERTISED_10baseT_Half;
+	if (advert & ADVERTISE_10FULL)
+		cmd->advertising |= ADVERTISED_10baseT_Full;
+	if (advert & ADVERTISE_100HALF)
+		cmd->advertising |= ADVERTISED_100baseT_Half;
+	if (advert & ADVERTISE_100FULL)
+		cmd->advertising |= ADVERTISED_100baseT_Full;
+	if (advert2 & ADVERTISE_1000FULL)
+		cmd->advertising |= ADVERTISED_1000baseT_Full;
+			
+	bmcr = ast_ether_phy_read_register(dev, priv->phy_addr, MII_BMCR);
+	lpa = ast_ether_phy_read_register(dev, priv->phy_addr, MII_LPA);
+    if (priv->supports_gmii) {
+        bmcr2 = ast_ether_phy_read_register(dev, priv->phy_addr, MII_CTRL1000);
+        lpa2 = ast_ether_phy_read_register(dev, priv->phy_addr, MII_STAT1000);
+    }
+	if (bmcr & BMCR_ANENABLE) {
+		cmd->autoneg = AUTONEG_ENABLE;
+		cmd->advertising |= ADVERTISED_Autoneg;
+		if (advert & ADVERTISE_PAUSE_CAP)
+			cmd->advertising |= ADVERTISED_Pause;
+		if (advert & ADVERTISE_PAUSE_ASYM)
+			cmd->advertising |= ADVERTISED_Asym_Pause;
+		nego = mii_nway_result(advert & lpa);
+
+        if ((bmcr2 & (ADVERTISE_1000HALF | ADVERTISE_1000FULL)) &
+		    (lpa2 >> 2))
+			cmd->speed = SPEED_1000;
+            
+		else if (nego == LPA_100FULL || nego == LPA_100HALF)
+			cmd->speed = SPEED_100;
+		else
+			cmd->speed = SPEED_10;
+
+        if ((lpa2 & LPA_1000FULL) || nego == LPA_100FULL ||
+            nego == LPA_10FULL) 
+			cmd->duplex = DUPLEX_FULL;
+		else
+			cmd->duplex = DUPLEX_HALF;
+	} else {
+		cmd->autoneg = AUTONEG_DISABLE;
+
+        cmd->speed = ((bmcr & BMCR_SPEED1000 &&
+            (bmcr & BMCR_SPEED100) == 0) ? SPEED_1000 :
+                (bmcr & BMCR_SPEED100) ? SPEED_100 : SPEED_10);
+		cmd->duplex = (bmcr & BMCR_FULLDPLX) ? DUPLEX_FULL : DUPLEX_HALF;
+	}
+
+	return 0;
+}
+
+static int ast_ether_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+    struct ast_ether_priv *priv = netdev_priv(dev);
+	uint32_t bmcr, advert, tmp;
+	uint32_t advert2 = 0, tmp2 = 0;
+
+	ast_ether_read_phy_id(dev);
+
+	if(priv->phy_oui == 0)
+		return 0;/* not supported PHY or NC-SI */
+
+	ast_ether_phy_write_register(dev, priv->phy_addr, MII_BMCR, BMCR_RESET);
+	mdelay(1);
+
+	if (cmd->speed != SPEED_10 && cmd->speed != SPEED_100 && cmd->speed != SPEED_1000)
+	{
+		ast_ether_enable_expand_regs_and_clk(dev);
+		return -EINVAL;
+	}
+	if (cmd->duplex != DUPLEX_HALF && cmd->duplex != DUPLEX_FULL)
+	{
+		ast_ether_enable_expand_regs_and_clk(dev);
+		return -EINVAL;
+	}
+	if (cmd->autoneg != AUTONEG_DISABLE && cmd->autoneg != AUTONEG_ENABLE)
+	{
+		ast_ether_enable_expand_regs_and_clk(dev);
+		return -EINVAL;
+	}
+
+	if (cmd->autoneg == AUTONEG_ENABLE) {
+		if ((cmd->advertising & (ADVERTISED_10baseT_Half | 
+                                 ADVERTISED_10baseT_Full | 
+                                 ADVERTISED_100baseT_Half |
+                                 ADVERTISED_100baseT_Full | 
+                                 ADVERTISED_1000baseT_Half | 
+                                 ADVERTISED_1000baseT_Full)) == 0)
+		{
+			ast_ether_enable_expand_regs_and_clk(dev);
+			return -EINVAL;
+		}
+
+		/* advertise only what has been requested */
+		advert = ast_ether_phy_read_register(dev, priv->phy_addr, MII_ADVERTISE);
+		tmp = advert & ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
+		
+        if (priv->supports_gmii) {
+			advert2 = ast_ether_phy_read_register(dev, priv->phy_addr, MII_CTRL1000);
+			tmp2 = advert2 & ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL);
+		}
+		
+		if (cmd->advertising & ADVERTISED_10baseT_Half)
+			tmp |= ADVERTISE_10HALF;
+		if (cmd->advertising & ADVERTISED_10baseT_Full)
+			tmp |= ADVERTISE_10FULL;
+		if (cmd->advertising & ADVERTISED_100baseT_Half)
+			tmp |= ADVERTISE_100HALF;
+		if (cmd->advertising & ADVERTISED_100baseT_Full)
+			tmp |= ADVERTISE_100FULL;
+		if (priv->supports_gmii) {
+			if (cmd->advertising & ADVERTISED_1000baseT_Half)
+                tmp2 |= ADVERTISE_1000HALF;
+			if (cmd->advertising & ADVERTISED_1000baseT_Full)
+				tmp2 |= ADVERTISE_1000FULL;
+		}
+		tmp &= ~ADVERTISE_PAUSE_CAP;
+		tmp &= ~ADVERTISE_PAUSE_ASYM;
+		
+		if (cmd->advertising & ADVERTISED_Pause)
+		{			
+			tmp |= ADVERTISE_PAUSE_CAP;
+		}			
+		if (cmd->advertising & ADVERTISED_Asym_Pause)
+		{			
+			tmp |= ADVERTISE_PAUSE_ASYM;
+		}			
+
+		if (advert != tmp) {
+			ast_ether_phy_write_register(dev, priv->phy_addr, MII_ADVERTISE, tmp);
+		}
+		mdelay(1);
+		if ((priv->supports_gmii) && (advert2 != tmp2))
+			ast_ether_phy_write_register(dev, priv->phy_addr, MII_CTRL1000, tmp2);
+		
+		mdelay(1);
+		/* turn on auto negotiation, and force a re-negotiate */
+		bmcr = ast_ether_phy_read_register(dev, priv->phy_addr, MII_BMCR);
+		bmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);
+		ast_ether_phy_write_register(dev, priv->phy_addr, MII_BMCR, bmcr);
+		mdelay(1);
+	} else {
+        if ((cmd->speed == SPEED_1000) && (cmd->duplex == DUPLEX_HALF)) /* not supported */
+        {
+        	ast_ether_enable_expand_regs_and_clk(dev);
+			return -EINVAL;
+        }
+		/* turn off auto negotiation, set speed and duplexity */
+		bmcr = ast_ether_phy_read_register(dev, priv->phy_addr, MII_BMCR);
+		tmp = bmcr & ~(BMCR_ANENABLE | BMCR_SPEED100 |
+			       BMCR_SPEED1000 | BMCR_FULLDPLX);
+
+        if (cmd->speed == SPEED_1000) {
+            tmp |= BMCR_SPEED1000;
+            tmp |= (BMCR_ANENABLE | BMCR_ANRESTART);  /* Don't know why connection lost if auto negotiation is off */
+        } else if (cmd->speed == SPEED_100)
+			tmp |= BMCR_SPEED100;
+		if (cmd->duplex == DUPLEX_FULL)
+			tmp |= BMCR_FULLDPLX;
+		if (bmcr != tmp)
+			ast_ether_phy_write_register(dev, priv->phy_addr, MII_BMCR, tmp);
+		mdelay(1);
+	}
+
+	ast_ether_enable_expand_regs_and_clk(dev);
+
+	return 0;
+}
+static void ast_ether_get_pauseparam(struct net_device *dev,
+		                                 struct ethtool_pauseparam *pause)
+{
+#if AST_PAUSE_FR_ENABLE	
+	struct ethtool_cmd ecmd;
+	memset (&ecmd, 0 , sizeof (struct ethtool_cmd));
+
+	ast_ether_get_settings(dev, &ecmd);
+	pause->autoneg  = ecmd.autoneg;
+
+	if (ecmd.advertising & ADVERTISED_Asym_Pause)
+	{		
+		if (ecmd.advertising & ADVERTISED_Pause)			
+		{			
+			pause->rx_pause = 1;
+			pause->tx_pause = 0;
+		}			
+		else
+		{			
+			pause->rx_pause = 0;
+			pause->tx_pause = 1;
+		}			
+
+	}		
+	else if (ecmd.advertising & ADVERTISED_Pause)
+	{		
+		pause->rx_pause = 1;
+		pause->tx_pause = 1;
+	}		
+	else
+	{
+		pause->rx_pause = 0;
+		pause->tx_pause = 0;
+	}
+#endif			
+}
+
+
+static int ast_ether_set_pauseparam(struct net_device *dev,
+		                                struct ethtool_pauseparam *pause)
+{
+#if AST_PAUSE_FR_ENABLE	
+	struct ast_ether_priv *priv = netdev_priv(dev);
+	struct ethtool_cmd ecmd;
+	u32 advert = 0, tmp;
+	unsigned int reg_value=0;
+	unsigned int ioaddr;
+
+	ioaddr = dev->base_addr;
+	reg_value = inl(ioaddr + AST_ETHER_FCR);
+	memset (&ecmd, 0 , sizeof (struct ethtool_cmd));
+	ast_ether_get_settings(dev, &ecmd);
+	if (ecmd.duplex == DUPLEX_FULL)		
+	{
+		advert = ast_ether_phy_read_register(dev, priv->phy_addr, MII_ADVERTISE);
+		tmp=advert;
+		if (pause->rx_pause)
+		{			
+			if(pause->tx_pause)
+			{	
+				ecmd.advertising |= ADVERTISED_Pause;
+				ecmd.advertising &= ~ADVERTISED_Asym_Pause;
+				ast_ether_set_settings (dev, &ecmd);
+				reg_value |= 0x05;
+			}			
+			else
+			{
+				tmp |= ADVERTISE_PAUSE_CAP;
+	                        tmp |= ADVERTISE_PAUSE_ASYM;
+				reg_value |= 0x01;
+				reg_value &= ~0x04;
+			}
+		}			
+		else if (pause->tx_pause)
+		{
+			tmp &= ~ADVERTISE_PAUSE_CAP;
+	                tmp |= ADVERTISE_PAUSE_ASYM;
+			reg_value |= 0x05;
+		}			
+		else
+		{
+			ecmd.advertising &= ~ADVERTISED_Pause;
+			ecmd.advertising &= ~ADVERTISED_Asym_Pause;
+			ast_ether_set_settings (dev, &ecmd);
+			reg_value &= ~0x05;
+		}			
+		outl(reg_value, ioaddr + AST_ETHER_FCR);
+		if (advert != tmp) {
+			ast_ether_phy_write_register(dev, priv->phy_addr, MII_ADVERTISE, tmp);
+		}
+	}	
+#endif	
+	return 0;			
+}	
+
+
+static const struct ethtool_ops ast_ether_ethtool_ops = {
+	.get_settings = ast_ether_get_settings,
+	.set_settings = ast_ether_set_settings,
+	.get_link = ethtool_op_get_link,
+ 	.set_pauseparam = ast_ether_set_pauseparam,
+	.get_pauseparam = ast_ether_get_pauseparam,
+};
+
+static const struct net_device_ops ast_netdev_ops = {
+	ndo_open:		ast_ether_open,
+	ndo_stop:		ast_ether_close,
+	ndo_start_xmit:		ast_ether_tx,
+	ndo_tx_timeout:		ast_ether_timeout,
+	ndo_get_stats:		ast_ether_get_stats,
+#ifdef  HAVE_MULTICAST
+	ndo_set_multicast_list:ast_ether_set_multicast_list,
+#else	
+	ndo_set_rx_mode:	ast_ether_set_multicast_list,
+#endif
+	ndo_set_mac_address:	eth_mac_addr,
+};
+
+static int ast_ether_init_one(int id)
+{
+	struct net_device *dev;
+	struct ast_ether_priv *priv;
+	int err;
+
+	ast_ether_netdev[id] = NULL;
+
+	/* alloc_etherdev ensures aligned and zeroed private structures */
+	dev = alloc_etherdev(sizeof(struct ast_ether_priv));
+	if (!dev)
+		return -ENOMEM;
+
+	if (!request_mem_region(ast_ether_phys_base[id], AST_ETHER_IO_REG_SIZE, "ast_ether")) {
+		err = -EBUSY;
+		goto out_alloc_etherdev;
+	}
+
+	dev->base_addr = (unsigned long)ioremap(ast_ether_phys_base[id], AST_ETHER_IO_REG_SIZE);
+	if (!dev->base_addr) {
+		err = -ENOMEM;
+		goto out_release_mem_region;
+	}
+
+	dev->irq = ast_ether_irq[id];
+	IRQ_SET_HIGH_LEVEL(dev->irq);
+	IRQ_SET_LEVEL_TRIGGER(dev->irq);
+
+	dev->dev_id = 0;
+
+	dev->netdev_ops = &ast_netdev_ops;
+
+	err = register_netdev(dev);
+	if (err != 0) {
+		goto out_iomap;
+	}
+
+	ether_setup(dev); /* Fill in the fields of the device structure with ethernet values. */
+	dev->ethtool_ops = &ast_ether_ethtool_ops;
+	/*
+	 * initialize private data structure 'priv'
+	 * it is zeroed and aligned in alloc_etherdev
+	 */
+	priv = netdev_priv(dev);
+
+	priv->idx = id;
+	ast_ether_get_hardware_addr(dev);
+
+	//priv->dev = dev;
+	spin_lock_init(&priv->lock);
+
+	priv->maccr = MACCR_CRC_APD | MACCR_RXMAC_EN | MACCR_TXMAC_EN | MACCR_RXDMA_EN | MACCR_TXDMA_EN | MACCR_RX_BROADPKT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_RUNT;
+
+	ast_ether_alloc_descriptor(dev);
+	priv->link_state = -1;
+
+	ast_ether_netdev[id] = dev;
+	return 0;
+
+out_iomap:
+	iounmap((void *) dev->base_addr);
+out_release_mem_region:
+	release_mem_region(ast_ether_phys_base[id], AST_ETHER_IO_REG_SIZE);
+out_alloc_etherdev:
+	free_netdev(dev);
+
+	return err;
+}
+
+#define AST_SCU_CLK_STOP_MAC2            0x00200000 /* bit 21 */
+#define AST_SCU_CLK_STOP_MAC1            0x00100000 /* bit 20 */
+
+#define AST_SCU_RESET_MAC2               0x00001000 /* bit 12 */
+#define AST_SCU_RESET_MAC1               0x00000800 /* bit 11 */
+
+#define AST_SCU_SET_MAC1_MULTI_PIN       0xC0000000
+#define AST_SCU_SET_MAC2_MULTI_PIN       0x00000004
+#define AST_SCU_UNLOCK_MAGIC             0x1688A8A8
+
+void __init ast_ether_set_multipin(void)
+{
+	uint32_t reg;
+
+	iowrite32(AST_SCU_UNLOCK_MAGIC, (void * __iomem)SCU_KEY_CONTROL_REG); /* unlock SCU */
+
+	/* Enable MAC1 Multi-function pin for AST in its SCU Multi function pin register */
+	reg = ioread32((void * __iomem)SCU_MULTI_FN_PIN_3);
+	reg |= AST_SCU_SET_MAC1_MULTI_PIN;
+	iowrite32(reg, (void * __iomem)SCU_MULTI_FN_PIN_3);
+
+	/* Enable MAC2 Multi-function pin for AST in its SCU Multi function pin register */
+	//reg = ioread32((void * __iomem)SCU_MULTI_FN_PIN_5);
+	//reg |= AST_SCU_SET_MAC2_MULTI_PIN;
+	//iowrite32(reg, (void * __iomem)SCU_MULTI_FN_PIN_5);
+
+	iowrite32(0, (void * __iomem)SCU_KEY_CONTROL_REG); /* lock SCU */
+
+	return;
+}
+
+void __init ast_ether_scu_init(void)
+{
+	uint32_t reg;
+
+	outl(AST_SCU_UNLOCK_MAGIC, SCU_KEY_CONTROL_REG); /* unlock SCU */
+
+	/* enable clcok */
+	reg = inl(SCU_CLK_STOP_REG);
+	reg &= ~(AST_SCU_CLK_STOP_MAC1 | AST_SCU_CLK_STOP_MAC2);
+	outl(reg, SCU_CLK_STOP_REG);
+
+	mdelay(10);
+
+	/* stop the reset */
+	reg = inl(SCU_SYS_RESET_REG);
+	reg &= ~(AST_SCU_RESET_MAC1 | AST_SCU_RESET_MAC2);
+	outl(reg, SCU_SYS_RESET_REG);
+
+	mdelay(10);
+
+	outl(0, SCU_KEY_CONTROL_REG); /* lock SCU */
+}
+
+int __init ast_ether_init(void)
+{
+	int result, id;
+
+	ast_ether_scu_init();
+	ast_ether_set_multipin();
+
+	result = -ENODEV;
+
+	for (id = 0; id < AST_ETHER_USE_NUM; id ++) {
+		if (ast_ether_init_one(id) == 0)
+			result = 0;
+	}
+	return result;
+}
+
+void ast_ether_exit(void)
+{
+	int id;
+	struct ast_ether_priv *priv;
+
+	for (id = 0; id < AST_ETHER_USE_NUM; id ++) {
+		if (ast_ether_netdev[id] == NULL)
+			continue;
+
+		priv = netdev_priv(ast_ether_netdev[id]);
+		if(priv->timer.function != NULL)
+			del_timer_sync(&priv->timer);
+		if (priv->rx_desc)
+			dma_free_coherent(NULL, sizeof(struct ast_eth_desc) * RX_DES_NUM, priv->rx_desc, priv->rx_desc_dma);
+		if (priv->tx_desc)
+			dma_free_coherent(NULL, sizeof(struct ast_eth_desc) * TX_DES_NUM, priv->tx_desc, priv->tx_desc_dma);
+
+		iounmap((void *) ast_ether_netdev[id]->base_addr);
+		release_mem_region(ast_ether_phys_base[id], AST_ETHER_IO_REG_SIZE);
+
+		unregister_netdev(ast_ether_netdev[id]);
+		free_netdev(ast_ether_netdev[id]);
+		ast_ether_netdev[id] = NULL;
+	}
+}
+
+module_init(ast_ether_init);
+module_exit(ast_ether_exit);
+
+MODULE_AUTHOR("American Megatrends Inc.");
+MODULE_DESCRIPTION("AST2050/AST2100/AST2150/AST2200/AST2300/AST2400 Ethernet MAC driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/aspeed/ast_ether.h b/drivers/net/ethernet/aspeed/ast_ether.h
new file mode 100644
index 0000000..0e0c5e9
--- /dev/null
+++ b/drivers/net/ethernet/aspeed/ast_ether.h
@@ -0,0 +1,330 @@
+#ifndef _AST_ETHER_H_
+#define _AST_ETHER_H_
+
+#ifdef CONFIG_SPX_FEATURE_GLOBAL_NIC_COUNT
+#define AST_ETHER_MAX_NUM       CONFIG_SPX_FEATURE_GLOBAL_NIC_COUNT
+#else
+#define AST_ETHER_MAX_NUM		2
+#endif
+#define AST_ETHER_USE_NUM		AST_ETHER_MAX_NUM
+
+#define AST_ETHER_REG_BASE1		0x1E660000
+#define AST_ETHER_REG_BASE2		0x1E680000
+#define AST_ETHER_REG_BASE3     0x1E670000
+#define AST_ETHER_REG_BASE4     0x1E690000
+
+#define AST_ETHER_IRQ1			2
+#define AST_ETHER_IRQ2			3
+#define AST_ETHER_IRQ3         23
+#define AST_ETHER_IRQ4         24
+
+#define AST_ETHER_IO_REG_SIZE	SZ_64K
+
+/*---------------------------------------------------------------------------*/
+
+/* registers offset */
+#define AST_ETHER_ISR			0x00 /* interrups status register */
+#define AST_ETHER_IER			0x04 /* interrupt enable register */
+#define AST_ETHER_MAC_MADR		0x08 /* MAC address (Most significant) */
+#define AST_ETHER_MAC_LADR		0x0c /* MAC address (Least significant) */
+#define AST_ETHER_MAHT0			0x10 /* Multicast Address Hash Table 0 register */
+#define AST_ETHER_MAHT1			0x14 /* Multicast Address Hash Table 1 register */
+#define AST_ETHER_TXPD			0x18 /* Transmit Poll Demand register */
+#define AST_ETHER_RXPD			0x1c /* Receive Poll Demand register */
+#define AST_ETHER_TXR_BADR		0x20 /* Transmit Ring Base Address register */
+#define AST_ETHER_RXR_BADR		0x24 /* Receive Ring Base Address register */
+#define AST_ETHER_HPTXPD		0x28 /* High Performance Transmit Poll Demand register */
+#define AST_ETHER_HPTXR_BADR	0x2c /* High Performance Transmit Ring Base Address register */
+#define AST_ETHER_ITC			0x30 /* interrupt timer control register */
+#define AST_ETHER_APTC			0x34 /* Automatic Polling Timer control register */
+#define AST_ETHER_DBLAC			0x38 /* DMA Burst Length and Arbitration control register */
+#define AST_ETHER_DMAFIFOS		0x3c /* DMA/FIFO state register */
+#define AST_ETHER_FEAR			0x44 /* Fearture register */
+#define AST_ETHER_TPAFCR		0x48 /* Transmit priority arbitration and FIFO control register */
+#define AST_ETHER_RBSR			0x4c /* Receive Buffer Size register */
+#define AST_ETHER_MACCR			0x50 /* MAC control register */
+#define AST_ETHER_MACSR			0x54 /* MAC status register */
+#define AST_ETHER_TEST_MODE		0x58 /* test mode register */
+#define AST_ETHER_PHYCR			0x60 /* PHY control register */
+#define AST_ETHER_PHYDATA		0x64 /* PHY Data register */
+#define AST_ETHER_FCR			0x68 /* Flow Control register */
+#define AST_ETHER_BPR			0x6c /* back pressure register */
+#define AST_ETHER_PWRTC			0x70 /* Power control register */
+
+/* bits of interrupt status/enable register */
+#define ISR_HPTXBUF_UNAVA			0x00000400
+#define ISR_PHYSTS_CHG				0x00000200 /* PHY link status change */
+#define ISR_AHB_ERR					0x00000100
+#define ISR_TPKT_LOST				0x00000080 /* collision / excessive collision / under-run */
+#define ISR_NPTXBUF_UNAVA			0x00000040
+#define ISR_TPKT2F					0x00000020 /* data from buffer to FIFO */
+#define ISR_TPKT2E					0x00000010 /* data from FIFO to ethernet */
+#define ISR_RPKT_LOST				0x00000008 /* Rx FIFO full */
+#define ISR_RXBUF_UNAVA				0x00000004
+#define ISR_RPKT2F					0x00000002 /* data from ethernet to FIFO */
+#define ISR_RPKT2B					0x00000001 /* data from FIFO to buffer */
+
+/* bits of interrupt timer control register */
+#define ITCR_TXINT_TIME_SEL			0x00008000
+#define ITCR_TXINT_THR_SHIFT		12
+#define ITCR_TXINT_THR_MASK			0x00007000
+#define ITCR_TXINT_CNT_SHIFT		8
+#define ITCR_TXINT_CNT_MASK			0x00000F00
+#define ITCR_RXINT_TIME_SEL			0x00000080
+#define ITCR_RXINT_THR_SHIFT		4
+#define ITCR_RXINT_THR_MASK			0x00000070
+#define ITCR_RXINT_CNT_SHIFT		0
+#define ITCR_RXINT_CNT_MASK			0x0000000F
+
+/* bits of automatic polling timer control register */
+#define APTC_TXPOLL_TIME_SEL		0x00001000
+#define APTC_TXPOLL_CNT_SHIFT		8
+#define APTC_TXPOLL_CNT_MASK		0x00000F00
+#define APTC_RXPOLL_TIME_SEL		0x00000010
+#define APTC_RXPOLL_CNT_SHIFT		0
+#define APTC_RXPOLL_CNT_MASK		0x0000000F
+
+/* bits of feature register */
+#define FEAR_TFIFO_RSIZE_SHIFT		3
+#define FEAR_TFIFO_RSIZE_MASK		0x00000038
+#define FEAR_RFIFO_RSIZE_SHIFT		0
+#define FEAR_RFIFO_RSIZE_MASK		0x00000007
+
+/* bits of transmit priority arbitration and FIFO control register */
+#define FPAFCR_TFIFO_SIZE_SHIFT		27
+#define FPAFCR_TFIFO_SIZE_MASK		0x38000000
+#define FPAFCR_RFIFO_SIZE_SHIFT		24
+#define FPAFCR_RFIFO_SIZE_MASK		0x07000000
+
+/* bits of receive buffer size register */
+#define RBSR_MASK					0x00003ff8 /* bits[13:3], 8-byte alignment */
+
+/* bits of MAC control register */
+#define MACCR_SW_RST				0x80000000 /* software reset */
+#define MACCR_SPEED_100				0x00080000 /* Speed mode */
+#define MACCR_DISCARD_CRCERR		0x00040000
+#define MACCR_RX_BROADPKT_EN		0x00020000 /* Receiving all broadcast packet */
+#define MACCR_RX_MULTIPKT_EN		0x00010000 /* receiving all multicast packet */
+#define MACCR_RX_HT_EN				0x00008000 /* enable multicast hast table */
+#define MACCR_RX_ALLADR				0x00004000 /* Destination address of incoming packet is not checked */
+#define MACCR_JUMBO_LF				0x00002000 /* Jumbo Long Frame */
+#define MACCR_RX_RUNT				0x00001000 /* Store incoming packet even its length is les than 64 byte */
+#define MACCR_CRC_APD				0x00000400 /* Append crc to transmit packet */
+#define MACCR_GMAC_MODE				0x00000200 /* 1000 Mpbs mode */
+#define MACCR_FULLDUP				0x00000100 /* full duplex */
+#define MACCR_ENRX_IN_HALFTX		0x00000080
+#define MACCR_PHY_LINK				0x00000040
+#define MACCR_HPTXR_EN				0x00000020
+#define MACCR_REMOVE_VLAN			0x00000010
+#define MACCR_RXMAC_EN				0x00000008 /* receiver enable */
+#define MACCR_TXMAC_EN				0x00000004 /* transmitter enable */
+#define MACCR_RXDMA_EN				0x00000002 /* enable DMA receiving channel */
+#define MACCR_TXDMA_EN				0x00000001 /* enable DMA transmitting channel */
+
+/* bits of PHY control register */
+#define PHYCR_WRITE					0x08000000
+#define PHYCR_READ					0x04000000
+#define PHYCR_REGAD_SHIFT			21
+#define PHYCR_REGAD_MASK			0x03E00000
+#define PHYCR_PHYAD_SHIFT			16
+#define PHYCR_PHYAD_MASK			0x001F0000
+#define PHYCR_MDC_CYCTHR_SHIFT		0
+#define PHYCR_MDC_CYCTHR_MASK		0x0000001F
+
+/*---------------------------------------------------------------------------*/
+
+/* PHY OUI */
+#define MARVELL_88E1111_OUI		0x005043
+#define BROADCOM_BCM5221_OUI	0x001018
+#define BROADCOM_BCM5241_OUI	0x0050EF
+#define BROADCOM_BCM5461_OUI    0x000818
+#define BROADCOM_BCM54612E_OUI  0x00D897
+#define BROADCOM_BCM5421_OUI    0x180361
+#define REALTEK_RTL82X1X_OUI	0x000732
+#define MICREL_KSZ80X1_OUI		0x000885
+
+/* addresses of PHY common registers */
+#define PHY_COM_REG_ADDR_CONTROL 0
+#define PHY_COM_REG_ADDR_STATUS 1
+#define PHY_COM_REG_ADDR_ID_HI 2
+#define PHY_COM_REG_ADDR_ID_LO 3
+
+/* PHY basic controler register - Register 0 */
+#define PHY_COM_REG_CONTROL_SPEED		0x2000 /* bit 13 */
+#define PHY_COM_REG_CONTROL_RE_AUTO		0x0200 /* bit 9 */
+#define PHY_COM_REG_CONTROL_DUPLEX		0x0100 /* bit 8 */
+
+/* PHY basic status register - Register 1 */
+#define PHY_COM_REG_STATUS_AUTO_OK		0x0020
+#define PHY_COM_REG_STATUS_LINK			0x0004
+
+/* addresses of Marvell 88E1111 PHY specific registers */
+#define MARVELL_88E1111_REG_ADDR_PHY_STATUS 17
+#define MARVELL_88E1111_REG_ADDR_INTR_CTRL 18
+#define MARVELL_88E1111_REG_ADDR_INTR_STATUS 19
+
+/* Bits of Marvell 88E1111 PHY Specific Status Register - Page 0, Register 17 */
+#define MARVELL_88E1111_REG_PHY_STATUS_RESOLVED			0x0800
+#define MARVELL_88E1111_REG_PHY_STATUS_SPEED_MASK		0xC000
+#define MARVELL_88E1111_REG_PHY_STATUS_DUPLEX_MASK		0x2000
+
+/* addresses of Broadcom BCM5221 PHY specific registers */
+#define BROADCOM_BCM5221_REG_ADDR_AUX_CTRL_STAT		0x18
+
+/* Bits of Broadcom BCM5221 Auxiliary Control/Status Register - Register 0x18 */
+#define BROADCOM_BCM5221_REG_AUX_CTRL_STAT_SPEED	0x0002
+#define BROADCOM_BCM5221_REG_AUX_CTRL_STAT_DEPLEX	0x0001
+
+/* addresses of Realtek RTL8211B PHY specific status register */
+#define REALTEK_RTL8211B_REG_ADDR_PHY_STAT		0x11
+
+/* addresses of Realtek RTL8211F PHY specific status register */
+#define REALTEK_RTL8211F_REG_ADDR_PHY_STAT		0x1A
+
+/* Bits of ealtek RTL8211B PHY specific status register - Register 0x11 */
+#define REALTEK_RTL8211B_REG_ADDR_PHY_STS_SPEED_MASK		0xC000 /* bits[15:14] */
+#define REALTEK_RTL8211B_REG_ADDR_PHY_STS_SPEED_SHIFT		14
+#define REALTEK_RTL8211B_REG_ADDR_PHY_STS_DEPLEX			0x2000 /* bit 13 */
+
+/* Bits of ealtek RTL8211F PHY specific status register - Register 0x1A */
+#define REALTEK_RTL8211F_REG_ADDR_PHY_STS_SPEED_MASK		0x0030 
+#define REALTEK_RTL8211F_REG_ADDR_PHY_STS_SPEED_SHIFT		4
+#define REALTEK_RTL8211F_REG_ADDR_PHY_STS_DEPLEX			0x0008 
+
+#define MICREL_KSZ8031_REG_STATUS		0x1E
+#define MICREL_KSZ8041_REG_STATUS		0x1F
+#define MICREL_KSZ9031_REG_STATUS		0x1F
+
+#define MICREL_KSZ8031_REG_STATUS_MASK			0x0007 /* bits[2:0] */
+#define MICREL_KSZ8041_REG_STATUS_MASK			0x001C /* bits[4:2] */
+#define MICREL_KSZ8041_REG_STATUS_SHIFT			2
+#define MICREL_KSZ8041_REG_STATUS_FULL_100		0x0006 /* 110 */
+#define MICREL_KSZ8041_REG_STATUS_FULL_10		0x0005 /* 101 */
+#define MICREL_KSZ8041_REG_STATUS_HALF_100		0x0002 /* 010 */
+#define MICREL_KSZ8041_REG_STATUS_HALF_10		0x0001 /* 001 */
+
+/* these valuse are the same for almost every PHY */
+#define PHY_DUPLEX_HALF		0x00
+#define PHY_DUPLEX_FULL		0x01
+
+#define PHY_SPEED_10M		0x00
+#define PHY_SPEED_100M		0x01
+#define PHY_SPEED_1000M		0x02
+
+/*---------------------------------------------------------------------------*/
+
+/* bits of Tx descriptor */
+#define TX_DESC_TXDMA_OWN		0x80000000	/* TX Own Bit */
+#define TX_DESC_EDOTR			0x40000000	/* TX End Of Ring */
+#define TX_DESC_FTS				0x20000000	/* TX First Descriptor Segment */
+#define TX_DESC_LTS				0x10000000	/* TX Last Descriptor Segment */
+#define TX_DESC_CRC_ERR			0x00080000	/* Tx CRC error */
+#define TX_DESC_TXBUF_SIZE		0x00003fff	/* Tx buffer size in byte */
+
+#define TX_DESC_TXIC        	0x80000000	/* TX interrupt on completion */
+#define TX_DESC_TX2FIC			0x40000000	/* TX to FIFO interrupt on completion */
+#define TX_DESC_IPCS_EN			0x00080000	/* TX IP checksum offlad enable */
+#define TX_DESC_UDPCS_EN		0x00040000	/* TX UDP checksum offlad enable */
+#define TX_DESC_TCPCS_EN		0x00020000	/* Tx TCP checksum offlad enable */
+
+/* bits of Rx descriptor */
+#define RX_DESC_RXPKT_RDY		0x80000000	/* RX Own Bit */
+#define RX_DESC_EDORR			0x40000000	/* RX End Of Ring */
+#define RX_DESC_FRS				0x20000000	/* RX First Descriptor Segment */
+#define RX_DESC_LRS				0x10000000	/* RX Last Descriptor Segment */
+#define RX_DESC_FIFO_FULL		0x00800000
+#define RX_DESC_RX_ODD_NB		0x00400000
+#define RX_DESC_RUNT			0x00200000	/* runt packet */
+#define RX_DESC_FTL				0x00100000	/* frame too long */
+#define RX_DESC_CRC_ERR			0x00080000	/* CRC error */
+#define RX_DESC_RX_ERR			0x00040000	/* RX error */
+#define RX_DESC_BROADCAST		0x00020000	/* broadcast frame */
+#define RX_DESC_MULTICAST		0x00010000	/* multicast frame */
+#define RX_DESC_VDBC			0x00003fff
+
+#define RX_DESC_IPCS_FAIL		0x08000000	/* RX IP checksum offlad failure */
+#define RX_DESC_UDPCS_FAIL		0x04000000	/* RX UDP checksum offlad failure */
+#define RX_DESC_TCPCS_FAIL		0x02000000	/* Rx TCP checksum offlad failure */
+
+#define RX_DESC_PROTL_TYPE_MASK			0x00300000
+#define RX_DESC_PROTL_TYPE_UNKNOWN		0x00000000
+#define RX_DESC_PROTL_TYPE_IP			0x00100000
+#define RX_DESC_PROTL_TYPE_TCP			0x00200000
+#define RX_DESC_PROTL_TYPE_UDP			0x00300000
+
+/*---------------------------------------------------------------------------*/
+
+/* the length of buffer length has to be a power of two */
+#define RX_DES_NUM		32
+#define RX_BUF_SIZE		1536
+
+#define TX_DES_NUM		32
+#define TX_BUF_SIZE		1536
+
+struct ast_eth_desc {
+	volatile u32 status;
+	u32 vlan;
+	u32 reserved;
+	u32 buffer;
+};
+
+#define AST_PHY_STATUS_CHECK_INTERVAL		3 /* for PHY without interrupt */
+#define AST_BC_CHECK_INTERVAL			2 	
+
+/* store this information for the driver.. */
+struct ast_ether_priv {
+	struct net_device_stats stats;
+	
+	spinlock_t lock;
+	
+	/* virtual address of allocated descriptor */
+	struct ast_eth_desc *tx_desc;
+	struct ast_eth_desc *rx_desc;
+
+	/* bus address of allocated descriptor */
+	dma_addr_t tx_desc_dma;
+	dma_addr_t rx_desc_dma;
+	
+	struct sk_buff *tx_skbuff[TX_DES_NUM]; /* The saved address of a sent-in-place packet/buffer, for skfree(). */
+	struct sk_buff *rx_skbuff[RX_DES_NUM]; /* The addresses of receive-in-place skbuffs. */
+
+	/* streaming DMA mapping of socket buffer */
+	dma_addr_t tx_skb_dma[TX_DES_NUM];
+	dma_addr_t rx_skb_dma[TX_DES_NUM];
+
+	unsigned int cur_tx, cur_rx; /* The next free ring entry */
+	unsigned int dirty_tx, dirty_rx; /* The ring entries to be free()ed. */
+	
+	u32 maccr; /* saved value of MAC control register */
+
+	u32 phy_oui;
+	u8 phy_model;
+	u8 phy_rev;
+	u8 link_state;
+	u8 idx; /*Net Device Index*/
+    
+    u32 supports_gmii : 1; /* are GMII registers supported? */
+    
+	struct timer_list timer; /* status check timer for PHY without interrupt */
+#ifdef CONFIG_ASTMAC100_NAPI
+       struct net_device *dev;
+       struct napi_struct napi;
+#endif
+	u8 phy_addr;
+};
+
+#ifdef BROADCAST_BLACKLIST
+struct ast_bc{
+	unsigned long bc_count;
+	bool bc_ctr;
+	bool trans_busy_1;
+	bool trans_busy_2;
+	struct timer_list timer;
+};
+#endif
+#define AST_PAUSE_FR_ENABLE 1 
+
+extern void ast_ether_get_mac_addr(unsigned char *mac_addr);
+extern int ast_ether_eeprom_read(unsigned int offset, unsigned char *buffer, unsigned int cnt);
+ 
+#endif  /* _AST_ETHER_H_ */
diff --git a/drivers/net/ethernet/aspeed/ast_gmac.c b/drivers/net/ethernet/aspeed/ast_gmac.c
new file mode 100644
index 0000000..7ed82b8
--- /dev/null
+++ b/drivers/net/ethernet/aspeed/ast_gmac.c
@@ -0,0 +1,2451 @@
+//-----------------------------------------------------------------------------
+// Original version by Faraday handled Faraday GMAC and Marvell PHY:
+//  "Faraday FTGMAC Driver, (Linux Kernel 2.6.14) 06/16/06 - by Faraday\n"
+// Merged improvements from ASPEED to handle Broadcom PHY, and 1 or 2 ports.
+//  "ASPEED MAC Driver, (Linux Kernel 2.6.15.7) 10/02/07 - by ASPEED\n"
+// Further improvements:
+//
+//   -- Assume MAC1 has a PHY chip.  Read the chip type and handle Marvell
+//      or Broadcom, else don't touch PHY chip (if present).
+//
+//   -- If MAC2 is on, check if U-Boot enabled the MII2DC+MII2DIO pins.
+//      If yes, handle Marvell or Broadcom PHY.  If no, assume sideband RMII
+//      interface with no PHY chip.
+// 1.12/27/07 - by river@aspeed
+//   Workaround for the gigabit hash function
+// 2.12/27/07 - by river@aspeed
+//   Synchronize the EDORR bit with document, D[30], D[15] both are EDORR
+// 3.12/31/07 - by river@aspeed
+//   Add aspeed_i2c_init and aspeed_i2c_read function for DHCP
+// 4.04/10/2008 - by river@aspeed
+//   Synchronize the EDOTR bit with document, D[30] is EDOTR
+// 5.04/10/2008 - by river@aspeed
+//   Remove the workaround for multicast hash function in A2 chip
+// SDK 0.19
+// 6.05/15/2008 - by river@aspeed
+//   Fix bug of free sk_buff in wrong routine
+// 7.05/16/2008 - by river@aspeed
+//   Fix bug of skb_over_panic()
+// 8.05/22/2008 - by river@aspeed
+//   Support NCSI Feature
+// SDK 0.20
+// 9.07/02/2008 - by river@aspeed
+//   Fix TX will drop packet bug
+// SDK 0.21
+//10.08/06/2008 - by river@aspeed
+//   Add the netif_carrier_on() and netif_carrier_off()
+//11.08/06/2008 - by river@aspeed
+//   Fix the timer did not work after device closed
+// SDK0.22
+//12.08/12/2008 - by river@aspeed
+//   Support different PHY configuration
+// SDK0.23
+//13.10/14/2008 - by river@aspeed
+//   Support Realtek RTL8211BN Gigabit PHY
+//14.11/17/2008 - by river@aspeed
+//   Modify the allocate buffer to alignment to IP header
+// SDK0.26
+//15.07/28/2009 - by river@aspeed
+//   Fix memory leakage problem in using multicast
+//16.07/28/2009 - by river@aspeed
+//   tx_free field in the local structure should be integer
+//
+//
+//
+//AST2300 SDK 0.12
+//17.03/30/2010 - by river@aspeed
+//   Modify for AST2300's hardware CLOCK/RESET/MULTI-PIN configuration
+//18.03/30/2010 - by river@aspeed
+//   Fix does not report netif_carrier_on() and netif_carrier_off() when use MARVELL PHY
+//AST2300 SDK 0.13
+//17.06/10/2010 - by river@aspeed
+//   Support AST2300 A0
+//18.06/10/2010 - by river@aspeed
+//   EEPROM is at I2C channel 4 on AST2300 A0 EVB
+//AST2300 SDK 0.14
+//19.09/13/2010 - by river@aspeed
+//   Support Realtek RTL8201EL 10/100M PHY
+//AST2400 
+//20.06/25/2013 - by CC@aspeed
+//   Support BCM54612E 10/100/1000M PHY
+//21 18 Feb 2014  by vineshc@ami
+//    Removed all NCSI code.
+//    Added ethtool support
+//    Added WOL support
+//    NAPI support not yet implemented
+//-----------------------------------------------------------------------------
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <linux/pci.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+
+#include <linux/skbuff.h>
+
+#include "ast_gmac.h"
+
+#define DRV_NAME	"astgmac"
+#define DRV_VERSION	"0.14"				/* SDK Version*/
+
+#if defined(CONFIG_ARM)
+#include <mach/hardware.h>
+#include <asm/cacheflush.h>
+
+#elif defined(CONFIG_COLDFIRE)
+#include <asm/astsim.h>
+
+#else
+#err "Not define include for GMAC"
+#endif
+
+/*------------------------------------------------------------------------
+ .
+ . Configuration options, for the experienced user to change.
+ .
+ -------------------------------------------------------------------------*/
+
+/*
+ . DEBUGGING LEVELS
+ .
+ . 0 for normal operation
+ . 1 for slightly more details
+ . >2 for various levels of increasingly useless information
+ .    2 for interrupt tracking, status flags
+ .    3 for packet info
+ .    4 for complete packet dumps
+*/
+
+#define DO_PRINT(args...) printk(": " args)
+
+//#define FTMAC100_DEBUG  1
+
+#ifdef FTMAC100_DEBUG
+
+#if (FTMAC100_DEBUG > 2 )
+#define PRINTK3(args...) DO_PRINT(args)
+#else
+#define PRINTK3(args...)
+#endif
+
+#if FTMAC100_DEBUG > 1
+#define PRINTK2(args...) DO_PRINT(args)
+#else
+#define PRINTK2(args...)
+#endif
+
+#ifdef FTMAC100_DEBUG
+#define PRINTK(args...) DO_PRINT(args)
+#else
+#define PRINTK(args...)
+#endif
+
+/*
+ . A rather simple routine to print out a packet for debugging purposes.
+*/
+#if FTMAC100_DEBUG > 2
+static void print_packet( u8 *, int );
+#endif
+
+#else
+#define PRINTK3(args...)
+#define PRINTK2(args...)
+#define PRINTK(args...)
+
+#endif
+
+
+static int ast_ether_get_settings(struct net_device *dev, struct ethtool_cmd *cmd);	
+
+extern unsigned long enetaddr[][6];
+
+static void ast_ether_get_hardware_addr(struct net_device* dev)
+{
+	struct ftgmac100_priv *priv 	= (struct ftgmac100_priv *)dev->ml_priv;
+
+	memcpy(dev->dev_addr, enetaddr[priv->ids.macId], ETH_ALEN);
+}
+
+
+// --------------------------------------------------------------------
+//  WOL function
+// --------------------------------------------------------------------
+static void enable_wol_magicpkt_detection(unsigned int base_addr)
+{
+    /* set WOL magic packet detection bit */
+    outl( (inl(base_addr + WOLCR_REG) | WOL_MAGICPKT_EN_bit), base_addr + WOLCR_REG );
+}
+
+static void disable_wol_magicpkt_detection(unsigned int base_addr)
+{
+    /* clear WOL magic packet detection bit */
+    outl( (inl(base_addr + WOLCR_REG) & (~WOL_MAGICPKT_EN_bit)), base_addr + WOLCR_REG );
+}
+
+/* This function depends on user mode operation so should be invoked
+ * from process context only. The wakeup operation depends on
+ * powerctrlapp via /var/pipe/power */
+static void wol_perform_wakeup(struct work_struct *work)
+{
+    char *argv[] = { "/bin/sh", "-c", "/bin/echo -ne \\\\x00 > /var/pipe/power", NULL };
+    static char *envp[] = { NULL };
+
+	struct ftgmac100_priv *priv = container_of(work,struct ftgmac100_priv,wol_wakeup_work_queue);
+	printk("%s: Wake on LAN received \n",priv->netdev->name);
+
+    /* invoke user space program from kernel space */
+    if(call_usermodehelper( argv[0], argv, envp, UMH_WAIT_PROC ))
+    {
+        DO_PRINT("Error performing wakeup operation, check whether powerctrlapp is running\n");
+    }
+}
+
+
+
+static int ftgmac100_wait_to_send_packet(struct sk_buff * skb, struct net_device * dev);
+
+static volatile int trans_busy = 0;
+
+
+void ftgmac100_phy_rw_waiting(unsigned int ioaddr)
+{
+	unsigned int tmp;
+
+	do {
+		mdelay(10);
+		tmp =inl(ioaddr + PHYCR_REG);
+	} while ((tmp&(PHY_READ_bit|PHY_WRITE_bit)) > 0);
+}
+
+
+/*------------------------------------------------------------
+ . Reads a register from the MII Management serial interface
+ .-------------------------------------------------------------*/
+static u16 ftgmac100_read_phy_register(unsigned int ioaddr, u8 phyaddr, u8 phyreg)
+{
+	unsigned int tmp;
+
+	if (phyaddr > 0x1f)	// MII chip IDs are 5 bits long
+	    return 0xffff;
+
+	tmp = inl(ioaddr + PHYCR_REG);
+	tmp &= 0x3000003F;
+	tmp |=(phyaddr<<16);
+	tmp |=(phyreg<<(16+5));
+	tmp |=PHY_READ_bit;
+
+	outl( tmp, ioaddr + PHYCR_REG );
+	ftgmac100_phy_rw_waiting(ioaddr);
+
+	return (inl(ioaddr + PHYDATA_REG)>>16);
+}
+
+
+/*------------------------------------------------------------
+ . Writes a register to the MII Management serial interface
+ .-------------------------------------------------------------*/
+static void ftgmac100_write_phy_register(unsigned int ioaddr,
+	u8 phyaddr, u8 phyreg, u16 phydata)
+{
+	unsigned int tmp;
+
+	if (phyaddr > 0x1f)	// MII chip IDs are 5 bits long
+	    return;
+
+	tmp = inl(ioaddr + PHYCR_REG);
+	tmp &= 0x3000003F;
+	tmp |=(phyaddr<<16);
+	tmp |=(phyreg<<(16+5));
+	tmp |=PHY_WRITE_bit;
+
+	outl( phydata, ioaddr + PHYDATA_REG );
+	outl( tmp, ioaddr + PHYCR_REG );
+	ftgmac100_phy_rw_waiting(ioaddr);
+}
+
+static void ast_gmac_set_mac(struct ftgmac100_priv *priv, const unsigned char *mac)
+{
+	unsigned int maddr = mac[0] << 8 | mac[1];
+	unsigned int laddr = mac[2] << 24 | mac[3] << 16 | mac[4] << 8 | mac[5];
+
+	iowrite32(maddr, (void __iomem *)priv->netdev->base_addr + MAC_MADR_REG);
+	iowrite32(laddr, (void __iomem *)priv->netdev->base_addr + MAC_LADR_REG);
+}
+
+/*
+ * MAC1 always has MII MDC+MDIO pins to access PHY registers.  We assume MAC1
+ * always has a PHY chip, if MAC1 is enabled.
+ * U-Boot can enable MAC2 MDC+MDIO pins for a 2nd PHY, or MAC2 might be
+ * disabled (only one port), or it's sideband-RMII which has no PHY chip.
+ *
+ * Return miiPhyId==0 if the MAC cannot be accessed.
+ * Return miiPhyId==1 if the MAC registers are OK but it cannot carry traffic.
+ * Return miiPhyId==2 if the MAC can send/receive but it has no PHY chip.
+ * Else return the PHY 22-bit vendor ID, 6-bit model and 4-bit revision.
+ */
+static void getMacHwConfig( struct net_device* dev, struct AstMacHwConfig* out )
+{
+
+
+//	out->macId   = dev->dev_id;
+//..	getMacAndPhy(dev, out);
+	out->miiPhyId = 0;
+
+	// We assume the Clock Stop register does not disable the MAC1 or MAC2 clock
+	// unless Reset Control also holds the MAC in reset.
+	// For now, we only support a PHY chip on the MAC's own MDC+MDIO bus.
+	if (out->phyAddr > 0x1f) {
+no_phy_access:
+	out->phyAddr = 0xff;
+	return;
+	}
+
+
+	out->miiPhyId = ftgmac100_read_phy_register(dev->base_addr, out->phyAddr, 0x02);
+	if (out->miiPhyId == 0xFFFF) { //Realtek PHY at address 1
+		out->phyAddr = 1;
+	}
+	if (out->miiPhyId == 0x0362) { 
+		out->phyAddr = 1;
+	}
+	out->miiPhyId = ftgmac100_read_phy_register(dev->base_addr, out->phyAddr, 0x02);
+	out->miiPhyId = (out->miiPhyId & 0xffff) << 16;
+	out->miiPhyId |= ftgmac100_read_phy_register(dev->base_addr, out->phyAddr, 0x03) & 0xffff;
+
+	switch (out->miiPhyId >> 16) {
+		case 0x0040:	// Broadcom
+		case 0x0141:	// Marvell
+		case 0x001c:	// Realtek
+		case 0x0362:	// BCM54612
+			break;
+
+		default:
+			// Leave miiPhyId for DO_PRINT(), but reset phyAddr.
+			// out->miiPhyId = 2;
+			goto no_phy_access;
+			break;
+	}
+	return;
+}
+
+
+static void ftgmac100_reset( struct net_device* dev )
+{
+	struct ftgmac100_priv *priv = (struct ftgmac100_priv *)dev->ml_priv;
+	struct AstMacHwConfig* ids = &priv->ids;
+	unsigned int tmp, speed, duplex;
+
+	getMacHwConfig(dev, ids);
+//	PRINTK("%s:ftgmac100_reset, phyAddr=0x%x, miiPhyId=0x%04x_%04x\n",
+//	       dev->name, ids->phyAddr, (ids->miiPhyId >> 16), (ids->miiPhyId & 0xffff));
+
+	if (ids->miiPhyId < 1)
+	    return;	// Cannot access MAC registers
+
+	// Check the link speed and duplex.
+	// They are not valid until auto-neg is resolved, which is reg.1 bit[5],
+	// or the link is up, which is reg.1 bit[2].
+
+	if (ids->phyAddr < 0xff)
+	    tmp = ftgmac100_read_phy_register(dev->base_addr, ids->phyAddr, 0x1);
+	else tmp = 0;
+
+	if (0==(tmp & (1u<<5 | 1u<<2)) || ids->phyAddr >= 0xff) {
+	    // No PHY chip, or link has not negotiated.
+	    speed  = PHY_SPEED_100M;
+	    duplex = 1;
+	    netif_carrier_off(dev);
+    }
+    else if ((priv->ids.miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_KSZ9031) {
+        tmp    = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x1F);
+        if ( (tmp & 0x0008) == 0x0008 )
+            duplex = 1;
+        else
+            duplex = 0;
+                                   
+        switch(tmp & 0x0070) {
+            case 0x0040:
+                speed = PHY_SPEED_1G; 
+                break;
+            case 0x0020:    
+                speed = PHY_SPEED_100M; 
+                break;
+            case 0x0010:    
+                speed = PHY_SPEED_10M;    
+                break;
+            default:
+                speed = PHY_SPEED_100M;
+        }               
+    }
+	else if (priv->ids.miiPhyId == PHYID_RTL8211FD) {
+        tmp    = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x1A);
+        if ( (tmp & 0x0008) == 0x0008 )
+            duplex = 1;
+        else
+            duplex = 0;
+                                   
+        switch(tmp & 0x0030) {
+            case 0x0020:
+                speed = PHY_SPEED_1G; 
+                break;
+            case 0x0010:    
+                speed = PHY_SPEED_100M; 
+                break;
+            case 0x0000:    
+                speed = PHY_SPEED_10M;    
+                break;
+            default:
+                speed = PHY_SPEED_100M;
+        }       
+	}
+	else if (((ids->miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8201EL)) {
+	    tmp    = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x00);
+	    duplex = (tmp & 0x0100) ? 1 : 0;
+	    speed  = (tmp & 0x2000) ? PHY_SPEED_100M : PHY_SPEED_10M;
+	}
+	else if (((ids->miiPhyId & PHYID_VENDOR_MASK) == PHYID_VENDOR_MARVELL) || 
+		 ((ids->miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8211)) {
+	    // Use reg.17_0.bit[15:13] for {speed[1:0], duplex}.
+	    tmp    = ftgmac100_read_phy_register(dev->base_addr, ids->phyAddr, 0x11);
+	    duplex = (tmp & PHY_DUPLEX_mask)>>13;
+	    speed  = (tmp & PHY_SPEED_mask)>>14;
+	    netif_carrier_on(dev);
+	}
+	else if (priv->ids.miiPhyId == PHYID_BCM54612E) { 
+       // Get link status
+        // First Switch shadow register selector
+        ftgmac100_write_phy_register(dev->base_addr, priv->ids.phyAddr, 0x1C, 0x2000);
+        tmp    = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x1C);
+        if ( (tmp & 0x0080) == 0x0080 )
+            duplex = 0;
+        else
+            duplex = 1;
+        
+        switch(tmp & 0x0018) {
+            case 0x0000:
+                speed = PHY_SPEED_1G; break;
+            case 0x0008:    
+                speed = PHY_SPEED_100M; break;
+            case 0x0010:    
+                speed = PHY_SPEED_10M; break;
+            default:
+                speed = PHY_SPEED_100M;
+        } 
+    }
+	else {
+	    // Assume Broadcom BCM5221.  Use reg.18 bits [1:0] for {100Mb/s, fdx}.
+	   // tmp    = ftgmac100_read_phy_register(dev->base_addr, ids->phyAddr, 0x18);
+	   // duplex = (tmp & 0x0001);
+	    //speed  = (tmp & 0x0002) ? PHY_SPEED_100M : PHY_SPEED_10M;
+
+			/* Default for unknown PHY */
+			struct ethtool_cmd cmd;
+			ast_ether_get_settings(dev,&cmd);
+	    	duplex = (cmd.duplex == DUPLEX_FULL)?1:0;
+			switch (cmd.speed)
+			{ 
+				case (SPEED_1000):
+                	speed = PHY_SPEED_1G; break;
+				case (SPEED_100):
+                	speed = PHY_SPEED_100M; break;
+				case (SPEED_10):
+                	speed = PHY_SPEED_10M; break;
+				default:
+                	speed = PHY_SPEED_100M; break;
+			}
+	}
+
+	if (speed == PHY_SPEED_1G) 
+	{
+	    // Set SPEED_100_bit too, for consistency.
+	  	printk("%s: Speed Set to 1G %s Duplex\n",dev->name,(duplex)?"Full":"Half");
+	    priv->maccr_val |= GMAC_MODE_bit | SPEED_100_bit;
+	    tmp = inl( dev->base_addr + MACCR_REG );
+	    tmp |= GMAC_MODE_bit | SPEED_100_bit;
+	    outl(tmp, dev->base_addr + MACCR_REG );
+	} 
+	else 
+	{
+	    priv->maccr_val &= ~(GMAC_MODE_bit | SPEED_100_bit);
+	    tmp = inl( dev->base_addr + MACCR_REG );
+	    tmp &= ~(GMAC_MODE_bit | SPEED_100_bit);
+	    if (speed == PHY_SPEED_100M) 
+		{
+	  		printk("%s: Speed Set to 100M %s Duplex\n",dev->name,(duplex)?"Full":"Half");
+			priv->maccr_val |= SPEED_100_bit;
+			tmp |= SPEED_100_bit;
+	    }
+		else
+	  		printk("%s: Speed Set to 10M %s Duplex\n",dev->name,(duplex)?"Full":"Half");
+	}
+
+	if (duplex)
+	{
+	    priv->maccr_val |= FULLDUP_bit;
+		tmp |= FULLDUP_bit;
+	}
+    else 
+	{
+		priv->maccr_val &= ~FULLDUP_bit;
+		tmp &= ~FULLDUP_bit;
+	}
+	outl(tmp, dev->base_addr + MACCR_REG );
+		
+	outl(SW_RST_bit, dev->base_addr + MACCR_REG );
+
+#ifdef not_complete_yet
+	/* Setup for fast accesses if requested */
+	/* If the card/system can't handle it then there will */
+	/* be no recovery except for a hard reset or power cycle */
+	if (dev->dma)
+	{
+		outw( inw( dev->base_addr + CONFIG_REG ) | CONFIG_NO_WAIT,
+		      dev->base_addr + CONFIG_REG );
+	}
+#endif /* end_of_not */
+
+	/* this should pause enough for the chip to be happy */
+	for (; (inl( dev->base_addr + MACCR_REG ) & SW_RST_bit) != 0; )
+	{
+		mdelay(10);
+		PRINTK3("RESET: reset not complete yet\n" );
+	}
+
+	outl( 0, dev->base_addr + IER_REG );			/* Disable all interrupts */
+}
+
+static void ftgmac100_enable( struct net_device *dev )
+{
+	int i;
+	struct ftgmac100_priv *priv 	= (struct ftgmac100_priv *)dev->ml_priv;
+	unsigned int tmp_rsize;		//Richard
+	unsigned int rfifo_rsize;	//Richard
+	unsigned int tfifo_rsize;	//Richard
+	unsigned int rxbuf_size;
+
+	rxbuf_size = RX_BUF_SIZE & 0x3fff;
+	outl( rxbuf_size , dev->base_addr + RBSR_REG); //for NC Body
+
+	for (i=0; i<RXDES_NUM; ++i)
+		priv->rx_descs[i].RXPKT_RDY = RX_OWNBY_FTGMAC100;				// owned by FTMAC100
+
+	priv->rx_idx = 0;
+
+	for (i=0; i<TXDES_NUM; ++i) {
+		priv->tx_descs[i].TXDMA_OWN = TX_OWNBY_SOFTWARE;			// owned by software
+		priv->tx_skbuff[i] = 0;
+	}
+
+	priv->tx_idx = 0;
+	priv->old_tx = 0;
+	priv->tx_free=TXDES_NUM;
+
+	/* Set the MAC address */
+	ast_gmac_set_mac(priv, dev->dev_addr);
+
+	outl( priv->rx_descs_dma, dev->base_addr + RXR_BADR_REG);
+	outl( priv->tx_descs_dma, dev->base_addr + TXR_BADR_REG);
+	outl( 0x00001010, dev->base_addr + ITC_REG);
+
+	outl( (0UL<<TXPOLL_CNT)|(0x1<<RXPOLL_CNT), dev->base_addr + APTC_REG);
+	outl( 0x44f97, dev->base_addr + DBLAC_REG );
+
+	outl(0xffff0805, dev->base_addr + FCR_REG );				// enable flow control
+	///	outl( inl(FCR_REG)|0x1, ioaddr + FCR_REG );				// enable flow control
+	///	outl( inl(BPR_REG)|0x1, ioaddr + BPR_REG );				// enable back pressure register
+
+	// +++++ Richard +++++ //
+	tmp_rsize = inl( dev->base_addr + FEAR_REG );
+	rfifo_rsize = tmp_rsize & 0x00000007;
+	tfifo_rsize = (tmp_rsize >> 3)& 0x00000007;
+
+	tmp_rsize = inl( dev->base_addr + TPAFCR_REG );
+	tmp_rsize &= ~0x3f000000;
+	tmp_rsize |= (tfifo_rsize << 27);
+	tmp_rsize |= (rfifo_rsize << 24);
+
+	outl(tmp_rsize, dev->base_addr + TPAFCR_REG);
+	// ----- Richard ----- //
+
+//river set MAHT0, MAHT1
+	if (priv->maccr_val & GMAC_MODE_bit) {
+		outl (priv->GigaBit_MAHT0, dev->base_addr + MAHT0_REG);
+		outl (priv->GigaBit_MAHT1, dev->base_addr + MAHT1_REG);
+	}
+	else {
+		outl (priv->Not_GigaBit_MAHT0, dev->base_addr + MAHT0_REG);
+		outl (priv->Not_GigaBit_MAHT1, dev->base_addr + MAHT1_REG);
+	}
+
+	/// enable trans/recv,...
+	outl(priv->maccr_val, dev->base_addr + MACCR_REG );
+/* Enable WOL magic packet detection */
+    enable_wol_magicpkt_detection(dev->base_addr);
+
+    if ((priv->ids.miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_KSZ9031) {
+        outl(
+// no link PHY link status pin            PHYSTS_CHG_bit      |
+            AHB_ERR_bit         |
+            TPKT_LOST_bit       |
+            TPKT2E_bit          |
+            RXBUF_UNAVA_bit     |
+            RPKT2B_bit
+            ,dev->base_addr + IER_REG
+            );
+    }   
+    else if (priv->ids.miiPhyId == PHYID_RTL8211FD) { 
+        outl(
+// no link PHY link status pin            PHYSTS_CHG_bit      |
+            AHB_ERR_bit         |
+            TPKT_LOST_bit       |
+            TPKT2E_bit          |
+            RXBUF_UNAVA_bit     |
+            RPKT2B_bit
+            ,dev->base_addr + IER_REG
+            );
+    }
+    else if (((priv->ids.miiPhyId & PHYID_VENDOR_MASK)       == PHYID_VENDOR_MARVELL) ||
+	    ((priv->ids.miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8211)) {
+		outl(
+			PHYSTS_CHG_bit		|
+			AHB_ERR_bit			|
+			TPKT_LOST_bit		|
+			TPKT2E_bit			|
+			RXBUF_UNAVA_bit		|
+			RPKT2B_bit
+        	,dev->base_addr + IER_REG
+       	 	);
+	}
+	else if (((priv->ids.miiPhyId & PHYID_VENDOR_MASK) == PHYID_VENDOR_BROADCOM) ||
+		 ((priv->ids.miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8201EL)) {
+		outl(
+			AHB_ERR_bit			|
+			TPKT_LOST_bit		|
+			TPKT2E_bit			|
+			RXBUF_UNAVA_bit		|
+			RPKT2B_bit
+        	,dev->base_addr + IER_REG
+       	 	);
+	}
+	else if (priv->ids.miiPhyId == PHYID_BCM54612E) { 
+        outl(
+// no link PHY link status pin            PHYSTS_CHG_bit      |
+            AHB_ERR_bit         |
+            TPKT_LOST_bit       |
+            TPKT2E_bit          |
+            RXBUF_UNAVA_bit     |
+            RPKT2B_bit
+            ,dev->base_addr + IER_REG
+            );
+    } else {
+		outl(
+// no link PHY link status pin			  PHYSTS_CHG_bit	  |
+			AHB_ERR_bit 		|
+			TPKT_LOST_bit		|
+			TPKT2E_bit			|
+			RXBUF_UNAVA_bit 	|
+			RPKT2B_bit
+			,dev->base_addr + IER_REG
+			);    
+    }
+}
+
+static void aspeed_mac_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct ftgmac100_priv *priv = (struct ftgmac100_priv *)dev->ml_priv;
+	unsigned int status, tmp, speed, duplex, macSpeed, macDuplex;
+
+#ifdef CONFIG_SOC_AST2300
+	//Fix issue for rx arbitration loss
+	outl( 0xffffffff, dev->base_addr + TXPD_REG);
+#endif
+
+	status = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x01);
+
+	if (status & LINK_STATUS) { // Bit[2], Link Status, link is up
+	    priv->timer.expires = jiffies + 10 * HZ;
+	    netif_carrier_on(dev);
+		if (priv->linkstatus == 1)
+		{
+				add_timer(&priv->timer);
+				return;
+		}
+		priv->linkstatus = 1;
+	  	printk("%s: Link Up\n",dev->name);
+
+        if ((priv->ids.miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_KSZ9031)
+        {
+            tmp    = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x1F);
+            if ( (tmp & 0x0008) == 0x0008 )
+                duplex = 1;
+            else
+                duplex = 0;
+                                   
+            switch(tmp & 0x0070) {
+                case 0x0040:
+                    speed = PHY_SPEED_1G; 
+                    break;
+                case 0x0020:    
+                    speed = PHY_SPEED_100M; 
+                    break;
+                case 0x0010:    
+                    speed = PHY_SPEED_10M;    
+                    break;
+                default:
+                    speed = PHY_SPEED_100M;
+            }        
+        }
+        else if (priv->ids.miiPhyId == PHYID_RTL8211FD) {
+            tmp    = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x1A);
+            if ( (tmp & 0x0008) == 0x0008 )
+                duplex = 1;
+            else
+                duplex = 0;
+                                   
+            switch(tmp & 0x0030) {
+                case 0x0020:
+                    speed = PHY_SPEED_1G;            
+                    break;
+                case 0x0010:    
+                    speed = PHY_SPEED_100M; 
+                    break;
+                case 0x0000:    
+                    speed = PHY_SPEED_10M;                                           
+                    break;
+                default:
+                    speed = PHY_SPEED_100M;
+            }        
+        }
+        else if ((priv->ids.miiPhyId & PHYID_VENDOR_MASK) == PHYID_VENDOR_BROADCOM) {
+	   	 	tmp    = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x18);
+	   	 	duplex = (tmp & 0x0001);
+	    	speed  = (tmp & 0x0002) ? PHY_SPEED_100M : PHY_SPEED_10M;
+		}
+		else if ((priv->ids.miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8201EL) {
+	    	tmp    = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x00);
+	    	duplex = (tmp & 0x0100) ? 1 : 0;
+	    	speed  = (tmp & 0x2000) ? PHY_SPEED_100M : PHY_SPEED_10M;
+		}
+		else if (((priv->ids.miiPhyId & PHYID_VENDOR_MASK) == PHYID_VENDOR_MARVELL) ||
+			 ((priv->ids.miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8211)) {
+	    	tmp    = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x11);
+	    	duplex = (tmp & PHY_DUPLEX_mask)>>13;
+	    	speed  = (tmp & PHY_SPEED_mask)>>14;
+		}
+		else if (priv->ids.miiPhyId == PHYID_BCM54612E) { 
+	    	// Get link status
+	   	 	// First Switch shadow register selector
+	    	ftgmac100_write_phy_register(dev->base_addr, priv->ids.phyAddr, 0x1C, 0x2000);
+	    	tmp    = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x1C);
+	    	if ( (tmp & 0x0080) == 0x0080 )
+	        	duplex = 0;
+	    	else
+	        	duplex = 1;
+	                               
+		    switch(tmp & 0x0018) {
+		        case 0x0000:
+	    	        speed = PHY_SPEED_1G; 
+
+	            	break;
+	        	case 0x0008:    
+	           		speed = PHY_SPEED_100M; 
+
+	            	break;
+	        	case 0x0010:    
+	           		speed = PHY_SPEED_10M; 
+
+	            	break;
+	        	default:
+	            	speed = PHY_SPEED_100M;
+	    	} 
+		}
+		else 
+		{
+			/* Default for unnown PHY */
+			struct ethtool_cmd cmd;
+			ast_ether_get_settings(dev,&cmd);
+	    	duplex = (cmd.duplex == DUPLEX_FULL)?1:0;
+			switch (cmd.speed)
+			{ 
+				case (SPEED_1000):
+                	speed = PHY_SPEED_1G; break;
+				case (SPEED_100):
+                	speed = PHY_SPEED_100M; break;
+				case (SPEED_10):
+                	speed = PHY_SPEED_10M; break;
+				default:
+                	speed = PHY_SPEED_100M; break;
+			}
+		}
+
+		
+ 		if (priv->maccr_val & GMAC_MODE_bit)   
+				macSpeed= PHY_SPEED_1G;
+		else
+		{
+ 			if (priv->maccr_val & SPEED_100_bit)
+				macSpeed = PHY_SPEED_100M;
+			else
+				macSpeed = PHY_SPEED_10M;   
+		}
+		macDuplex = ((priv->maccr_val&FULLDUP_bit)!=0);
+		
+	//  	printk("%s: Old Speed = %d New Speed = %d\n",dev->name,macSpeed,speed);
+	//  	printk("%s: Old Duplex = %d New Duplex = %d\n",dev->name,macDuplex,duplex);
+
+		if ((macDuplex != duplex) || (macSpeed != speed))
+		{
+	//		PRINTK("%s:aspeed_mac_timer, priv->maccr_val=0x%05x, PHY {speed,duplex}=%d,%d\n",
+	//		   dev->name, priv->maccr_val, speed, duplex);
+			ftgmac100_reset(dev);
+			ftgmac100_enable(dev);
+		}
+	    
+	}
+	else 
+	{
+		netif_carrier_off(dev);
+	    priv->timer.expires = jiffies + 1 * HZ;
+		if (priv->linkstatus == 0)
+		{
+				add_timer(&priv->timer);
+				return;
+		}
+		/* Set to Link Down and 10HD */
+		priv->linkstatus = 0;
+	    priv->maccr_val &= ~(GMAC_MODE_bit | SPEED_100_bit | FULLDUP_bit);
+	  	printk("%s: Link Down\n",dev->name);
+	}
+	add_timer(&priv->timer);
+}
+
+/*
+ . Function: ftgmac100_shutdown
+ . Purpose:  closes down the SMC91xxx chip.
+ . Method:
+ .	1. zero the interrupt mask
+ .	2. clear the enable receive flag
+ .	3. clear the enable xmit flags
+ .
+ . TODO:
+ .   (1) maybe utilize power down mode.
+ .	Why not yet?  Because while the chip will go into power down mode,
+ .	the manual says that it will wake up in response to any I/O requests
+ .	in the register space.   Empirical results do not show this working.
+*/
+static void ftgmac100_shutdown( unsigned int ioaddr )
+{
+   /* Disable WOL magic packet detection */
+    disable_wol_magicpkt_detection(ioaddr);
+
+	///interrupt mask register
+	outl( 0, ioaddr + IER_REG );
+	/* enable trans/recv,... */
+	outl( 0, ioaddr + MACCR_REG );
+}
+
+/*
+ . Function: ftgmac100_wait_to_send_packet( struct sk_buff * skb, struct device * )
+ . Purpose:
+ .    Attempt to allocate memory for a packet, if chip-memory is not
+ .    available, then tell the card to generate an interrupt when it
+ .    is available.
+ .
+ . Algorithm:
+ .
+ . o	if the saved_skb is not currently null, then drop this packet
+ .		on the floor.  This should never happen, because of TBUSY.
+ . o	if the saved_skb is null, then replace it with the current packet,
+ . o	See if I can sending it now.
+ . o 	(NO): Enable interrupts and let the interrupt handler deal with it.
+ . o	(YES):Send it now.
+*/
+static int ftgmac100_wait_to_send_packet( struct sk_buff * skb, struct net_device * dev )
+{
+	struct ftgmac100_priv *priv 	= (struct ftgmac100_priv *)dev->ml_priv;
+	unsigned long ioaddr 	= dev->base_addr;
+	volatile TX_DESC *cur_desc;
+	int		length;
+	unsigned long flags;
+	dma_addr_t map;
+
+	spin_lock_irqsave(&priv->tx_lock,flags);
+
+	if (skb==NULL)
+	{
+		DO_PRINT("%s(%d): NULL skb???\n", __FILE__,__LINE__);
+		spin_unlock_irqrestore(&priv->tx_lock, flags);
+		return 0;
+	}
+
+	PRINTK3("%s:ftgmac100_wait_to_send_packet, skb=%x\n", dev->name, skb);
+	cur_desc = &priv->tx_descs[priv->tx_idx];
+
+#ifdef not_complete_yet	
+	if (cur_desc->TXDMA_OWN != TX_OWNBY_SOFTWARE)		/// no empty transmit descriptor 
+	{
+		DO_PRINT("no empty transmit descriptor\n");
+		DO_PRINT("jiffies = %d\n", jiffies);
+		priv->stats.tx_dropped++;
+		netif_stop_queue(dev);		/// waiting to do: 
+		spin_unlock_irqrestore(&priv->tx_lock, flags);
+
+		return 1;
+   	}
+#endif /* end_of_not */
+
+	if (cur_desc->TXDMA_OWN != TX_OWNBY_SOFTWARE)		/// no empty transmit descriptor 
+	{
+		DO_PRINT("no empty TX descriptor:0x%x:0x%x\n",
+				(unsigned int)cur_desc,((unsigned int *)cur_desc)[0]);
+		priv->stats.tx_dropped++;
+		netif_stop_queue(dev);		/// waiting to do: 
+		spin_unlock_irqrestore(&priv->tx_lock, flags);
+
+		return 1;
+   	}
+	priv->tx_skbuff[priv->tx_idx] = skb;
+	length = (ETH_ZLEN < skb->len) ? skb->len : ETH_ZLEN;
+	length = min(length, TX_BUF_SIZE);
+
+#ifdef FTMAC100_DEBUG
+#if FTMAC100_DEBUG > 2
+	DO_PRINT("Transmitting Packet at 0x%x, skb->data = %x, len = %x\n",
+		 (unsigned int)cur_desc->VIR_TXBUF_BADR, skb->data, length);
+	print_packet( skb->data, length );
+#endif
+#endif
+
+	cur_desc->VIR_TXBUF_BADR = (unsigned long)skb->data;
+	cur_desc->TXBUF_BADR = virt_to_phys(skb->data);
+//	dmac_clean_range((void *)skb->data, (void *)(skb->data + length));
+	map = dma_map_single(priv->dev, skb->data, skb_headlen(skb), DMA_TO_DEVICE);
+
+	//clean_dcache_range(skb->data, (char*)(skb->data + length));
+
+	cur_desc->TXBUF_Size = length;
+	cur_desc->LTS = 1;
+	cur_desc->FTS = 1;
+
+	cur_desc->TX2FIC = 0;
+	cur_desc->TXIC = 0;
+
+	cur_desc->TXDMA_OWN = TX_OWNBY_FTGMAC100;
+
+	outl( 0xffffffff, ioaddr + TXPD_REG);
+
+	priv->tx_idx = (priv->tx_idx + 1) % TXDES_NUM;
+	priv->stats.tx_packets++;
+	priv->tx_free--;
+
+	if (priv->tx_free <= 0) {
+		netif_stop_queue(dev);
+
+	}
+
+
+	dev->trans_start = jiffies;
+	spin_unlock_irqrestore(&priv->tx_lock, flags);
+
+	return 0;
+}
+
+static int ftgmac100_ringbuf_alloc(struct ftgmac100_priv *priv)
+{
+	int i;
+	struct sk_buff *skb;
+
+    priv->rx_descs = dma_alloc_coherent(priv->dev, 
+								sizeof(RX_DESC)*RXDES_NUM, 
+								&priv->rx_descs_dma, GFP_KERNEL);
+
+	if(!priv->rx_descs)
+		return -ENOMEM;
+	
+	memset((void *)priv->rx_descs, 0, sizeof(RX_DESC)*RXDES_NUM);
+	priv->rx_descs[RXDES_NUM-1].EDORR = 1;
+
+	for (i=0; i<RXDES_NUM; i++) {
+		dma_addr_t mapping;	
+		skb = dev_alloc_skb(RX_BUF_SIZE + NET_IP_ALIGN);
+		skb_reserve(skb, NET_IP_ALIGN);
+
+		priv->rx_skbuff[i] = skb;
+		if (skb == NULL) {
+			printk ("alloc_list: allocate Rx buffer error! ");
+			break;
+		}
+		mapping = dma_map_single(priv->dev, skb->data, skb->len, DMA_FROM_DEVICE);
+		skb->dev = priv->netdev;	/* Mark as being used by this device. */
+		priv->rx_descs[i].RXBUF_BADR = mapping;
+		priv->rx_descs[i].VIR_RXBUF_BADR = (u32)skb->data;
+	}
+
+	priv->tx_descs = dma_alloc_coherent(priv->dev, 
+						sizeof(TX_DESC)*TXDES_NUM, 
+						&priv->tx_descs_dma ,GFP_KERNEL);
+
+	if(!priv->tx_descs)
+		return -ENOMEM;
+
+	memset((void*)priv->tx_descs, 0, sizeof(TX_DESC)*TXDES_NUM);
+	priv->tx_descs[TXDES_NUM-1].EDOTR = 1;			// is last descriptor
+	
+	return 0;
+}
+
+#ifdef FTMAC100_DEBUG
+#if FTMAC100_DEBUG > 2
+static void print_packet( u8 * buf, int length )
+{
+#if 1
+#if FTMAC100_DEBUG > 3
+	int i;
+	int remainder;
+	int lines;
+#endif
+
+
+#if FTMAC100_DEBUG > 3
+	lines = length / 16;
+	remainder = length % 16;
+
+	for ( i = 0; i < lines ; i ++ ) {
+		int cur;
+
+		for ( cur = 0; cur < 8; cur ++ ) {
+			u8 a, b;
+
+			a = *(buf ++ );
+			b = *(buf ++ );
+			DO_PRINT("%02x%02x ", a, b );
+		}
+		DO_PRINT("\n");
+	}
+	for ( i = 0; i < remainder/2 ; i++ ) {
+		u8 a, b;
+
+		a = *(buf ++ );
+		b = *(buf ++ );
+		DO_PRINT("%02x%02x ", a, b );
+	}
+	DO_PRINT("\n");
+#endif
+#endif
+}
+#endif
+#endif
+
+/*------------------------------------------------------------
+ . Configures the specified PHY using Autonegotiation.
+ .-------------------------------------------------------------*/
+static void ftgmac100_phy_configure(struct net_device* dev)
+{
+    struct ftgmac100_priv *priv = (struct ftgmac100_priv *)dev->ml_priv;
+    unsigned long ioaddr = dev->base_addr;
+	u32 tmp;
+//	printk("priv->ids.miiPhyId = %x \n",priv->ids.miiPhyId);
+	switch (priv->ids.miiPhyId & PHYID_VENDOR_MASK) {
+		case PHYID_VENDOR_MARVELL:
+			ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x12, 0x4400);
+			tmp = ftgmac100_read_phy_register(ioaddr, priv->ids.phyAddr, 0x13 );
+			break;
+		case PHYID_VENDOR_REALTEK:
+			switch (priv->ids.miiPhyId) {
+				case PHYID_RTL8211:
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x12, 0x4400);
+					tmp = ftgmac100_read_phy_register(ioaddr, priv->ids.phyAddr, 0x13 );
+					break;
+				case PHYID_RTL8201EL:
+					break;
+				case PHYID_RTL8201F:
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x1f, 0x0007);
+					tmp = ftgmac100_read_phy_register(ioaddr, priv->ids.phyAddr, 0x13 );
+					tmp &= ~(0x0030);
+					tmp |= 0x0008;
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x13, (u16) tmp);
+					tmp = ftgmac100_read_phy_register(ioaddr, priv->ids.phyAddr, 0x11);
+					tmp &= ~(0x0fff);
+					tmp |= 0x0008;
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x11, (u16) tmp);
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x1f, 0x0000);
+					break;
+                case PHYID_RTL8211FD:
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x1f, 0x0d04);
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x10, 0xc160);
+					tmp = ftgmac100_read_phy_register(ioaddr, priv->ids.phyAddr, 0x11);
+					tmp &= (0xfff1);
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x11, (u16) tmp);
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x1f, 0x0000);
+					break;
+			}
+			break;
+		case PHYID_VENDOR_BROADCOM:
+			switch (priv->ids.miiPhyId) {
+				case PHYID_BCM54612E:
+
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x17, 0xd34);
+					tmp = ftgmac100_read_phy_register(ioaddr, priv->ids.phyAddr, 0x15);
+					tmp |= 0x02;
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x15, tmp);
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x17, 0x00);
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x1C, 0x8C00); // Disable GTXCLK Clock Delay Enable
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x18, 0xF0E7); // Disable RGMII RXD to RXC Skew
+					break;			
+				case PHYID_BCM5221A4:
+				default:
+					tmp = ftgmac100_read_phy_register(ioaddr, priv->ids.phyAddr, 0x1b);
+					tmp |= 0x0004;
+					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x1b, (u16) tmp);
+					break;
+				}
+			break;			
+        case PHYID_VENDOR_MICREL:
+            switch (priv->ids.miiPhyId & PHYID_VENDOR_MODEL_MASK) {
+                case PHYID_KSZ9031:
+                    // implemented RJ45's LED function
+                    break;          
+                default:
+                    break;
+                }
+            break;
+		}
+}
+
+
+/*--------------------------------------------------------
+ . Called by the kernel to send a packet out into the void
+ . of the net.  This routine is largely based on
+ . skeleton.c, from Becker.
+ .--------------------------------------------------------
+*/
+static void ftgmac100_timeout (struct net_device *dev)
+{
+	/* If we get here, some higher level has decided we are broken.
+	There should really be a "kick me" function call instead. */
+	DO_PRINT(KERN_WARNING "%s: transmit timed out? (jiffies=%ld)\n",
+		 dev->name, jiffies);
+	/* "kick" the adaptor */
+	ftgmac100_reset( dev );
+	ftgmac100_enable( dev );
+
+	/* Reconfigure the PHY */
+	ftgmac100_phy_configure(dev);
+
+	netif_wake_queue(dev);
+	dev->trans_start = jiffies;
+}
+
+
+static void ftgmac100_free_tx (struct net_device *dev) 
+{
+ struct ftgmac100_priv *priv = (struct ftgmac100_priv *)dev->ml_priv;
+ int entry = priv->old_tx % TXDES_NUM; 
+ unsigned long flags = 0;
+ 
+ spin_lock_irqsave(&priv->tx_lock,flags);
+ 
+ /* Free used tx skbuffs */
+
+  while ((priv->tx_descs[entry].TXDMA_OWN == TX_OWNBY_SOFTWARE) && (priv->tx_skbuff[entry] != NULL)) {
+  struct sk_buff *skb;
+  
+  skb = priv->tx_skbuff[entry];
+         dev_kfree_skb_any (skb);
+  priv->tx_skbuff[entry] = 0;
+  entry = (entry + 1) % TXDES_NUM;
+  priv->tx_free++;
+ }
+ 
+ spin_unlock_irqrestore(&priv->tx_lock, flags);
+ priv->old_tx = entry;
+ if ((netif_queue_stopped(dev)) && (priv->tx_free > 0)) {
+ 	netif_wake_queue (dev);
+ }
+}
+
+
+/*-------------------------------------------------------------
+ .
+ . ftgmac100_rcv -  receive a packet from the card
+ .
+ . There is ( at least ) a packet waiting to be read from
+ . chip-memory.
+ .
+ . o Read the status
+ . o If an error, record it
+ . o otherwise, read in the packet
+ --------------------------------------------------------------
+*/
+// extern dce_dcache_invalidate_range(unsigned int start, unsigned int end);
+
+static void ftgmac100_rcv(struct net_device *dev)
+{
+	struct ftgmac100_priv *priv = (struct ftgmac100_priv *)dev->ml_priv;
+	unsigned long ioaddr 	= dev->base_addr;
+	int 	packet_length;
+	int 	rcv_cnt;
+	volatile RX_DESC *cur_desc;
+	int		cur_idx;
+	int		have_package;
+	int		have_frs;
+	int	 	start_idx;
+        int             count = 0;
+        int             packet_full = 0;
+	int		data_not_fragment = 1;
+
+	start_idx = priv->rx_idx;
+
+	for (rcv_cnt=0; rcv_cnt<RXDES_NUM ; ++rcv_cnt)
+	{
+		packet_length = 0;
+		cur_idx = priv->rx_idx;
+
+		have_package = 0;
+		have_frs = 0;
+
+		for (; (cur_desc = &priv->rx_descs[priv->rx_idx])->RXPKT_RDY==RX_OWNBY_SOFTWARE; )
+		{
+			have_package = 1;
+			priv->rx_idx = (priv->rx_idx+1)%RXDES_NUM;
+                        count++;
+                        if (count == RXDES_NUM) {
+                            packet_full = 1;
+                        }
+//DF_support
+                            if (data_not_fragment == 1) {
+                                if (!(cur_desc->DF)) {
+                                    data_not_fragment = 0;
+                                }
+                            }
+
+			if (cur_desc->FRS)
+			{
+				have_frs = 1;
+                if ( cur_desc->FIFO_FULL )
+                {
+                    DO_PRINT("info: RX_FIFO full\n");                    
+                }
+                else
+                {
+				if (cur_desc->RX_ERR || cur_desc->CRC_ERR || cur_desc->FTL ||
+				    cur_desc->RUNT || cur_desc->RX_ODD_NB
+				    // cur_desc->IPCS_FAIL || cur_desc->UDPCS_FAIL || cur_desc->TCPCS_FAIL
+				    )
+				{
+				//	#ifdef not_complete_yet
+					if (cur_desc->RX_ERR)
+					{
+						DO_PRINT("err: RX_ERR\n");
+					}
+					if (cur_desc->CRC_ERR)
+					{
+				//		DO_PRINT("err: CRC_ERR\n");
+					}
+					if (cur_desc->FTL)
+					{
+						DO_PRINT("err: FTL\n");
+					}
+					if (cur_desc->RX_ODD_NB)
+					{
+				//		DO_PRINT("err: RX_ODD_NB\n");
+				        }
+//				        if (cur_desc->IPCS_FAIL || cur_desc->UDPCS_FAIL || cur_desc->TCPCS_FAIL)
+//				        {
+//				        	DO_PRINT("err: CS FAIL\n");
+//				        }
+				//	#endif /* end_of_not */
+					priv->stats.rx_errors++;			// error frame....
+					break;
+                    }
+				}
+//DF_support
+                                    if (cur_desc->DF) {
+				        if (cur_desc->IPCS_FAIL || cur_desc->UDPCS_FAIL || cur_desc->TCPCS_FAIL)
+				        {
+				        	DO_PRINT("err: CS FAIL\n");
+					        priv->stats.rx_errors++;			// error frame....
+                                                break;
+				        }
+                                    }
+
+				if (cur_desc->MULTICAST)
+				{
+					priv->stats.multicast++;
+				}
+                if ((priv->NCSI_support == 1) || (priv->INTEL_NCSI_EVA_support == 1)) {
+                    if (cur_desc->BROADCAST) {
+                        if (*(unsigned short *)(cur_desc->VIR_RXBUF_BADR + 12) == NCSI_HEADER) {
+                            printk ("AEN PACKET ARRIVED\n");
+                            ftgmac100_reset(dev);
+                            ftgmac100_enable(dev);
+                            return;
+                        }
+                    }
+                }
+			}
+
+			packet_length += cur_desc->VDBC;
+
+//			if ( cur_desc->LRS )		// packet's last frame
+//			{
+				break;
+//			}
+		}
+		if (have_package==0)
+		{
+			goto done;
+		}
+		if (!have_frs)
+		{
+			DO_PRINT("error, loss first\n");
+			priv->stats.rx_over_errors++;
+		}
+
+		if (packet_length > 0)
+		{
+			struct sk_buff  * skb;
+			u8		* data = 0;  if (data) { }
+
+			packet_length -= 4;
+
+			skb_put (skb = priv->rx_skbuff[cur_idx], packet_length);
+
+// Rx Offload DF_support
+
+			    if (data_not_fragment) {
+				skb->ip_summed = CHECKSUM_UNNECESSARY;
+                                data_not_fragment = 1;
+                            }
+
+#ifdef FTMAC100_DEBUG
+#if FTMAC100_DEBUG > 2
+			DO_PRINT("Receiving Packet at 0x%x, packet len = %x\n",(unsigned int)data, packet_length);
+			print_packet( data, packet_length );
+#endif
+#endif
+
+			skb->protocol = eth_type_trans(skb, dev );
+			netif_rx(skb);
+			priv->stats.rx_packets++;
+			priv->rx_skbuff[cur_idx] = NULL;
+		}
+                if (packet_full) {
+//                  DO_PRINT ("RX Buffer full before driver entered ISR\n");
+                    goto done;
+                }
+	}
+
+done:
+
+        if (packet_full) {
+
+		struct sk_buff *skb;
+
+		for (cur_idx = 0; cur_idx < RXDES_NUM; cur_idx++)
+		{
+			if (priv->rx_skbuff[cur_idx] == NULL) {
+				dma_addr_t mapping; 
+				skb = dev_alloc_skb(RX_BUF_SIZE + NET_IP_ALIGN);
+				if (skb == NULL) {
+					printk (KERN_INFO
+						"%s: receive_packet: "
+						"Unable to re-allocate Rx skbuff.#%d\n",
+						dev->name, cur_idx);
+				}
+				
+				skb_reserve(skb, NET_IP_ALIGN);
+				
+				priv->rx_skbuff[cur_idx] = skb;
+				skb->dev = dev;
+				// ASPEED: See earlier skb_reserve() cache alignment
+				
+				mapping = dma_map_single(priv->dev, skb->data, skb->len, DMA_FROM_DEVICE);
+				priv->rx_descs[cur_idx].RXBUF_BADR = cpu_to_le32(virt_to_phys(skb->tail));
+				priv->rx_descs[cur_idx].VIR_RXBUF_BADR = cpu_to_le32((u32)skb->tail);
+			}
+		        priv->rx_descs[cur_idx].RXPKT_RDY = RX_OWNBY_FTGMAC100;
+                }
+                packet_full = 0;
+
+        }
+	else {
+            if (start_idx != priv->rx_idx) {
+		struct sk_buff *skb;
+
+		for (cur_idx = (start_idx+1)%RXDES_NUM; cur_idx != priv->rx_idx; cur_idx = (cur_idx+1)%RXDES_NUM)
+		{
+
+
+			//struct sk_buff *skb;
+			/* Dropped packets don't need to re-allocate */
+			if (priv->rx_skbuff[cur_idx] == NULL) {
+				dma_addr_t mapping; 
+				skb = dev_alloc_skb(RX_BUF_SIZE + NET_IP_ALIGN);
+				if (skb == NULL) {
+					printk (KERN_INFO
+						"%s: receive_packet: "
+						"Unable to re-allocate Rx skbuff.#%d\n",
+						dev->name, cur_idx);
+				}
+				
+				skb_reserve(skb, NET_IP_ALIGN);
+
+				priv->rx_skbuff[cur_idx] = skb;
+				skb->dev = dev;
+				mapping = dma_map_single(priv->dev, skb->data, skb->len, DMA_FROM_DEVICE);
+				priv->rx_descs[cur_idx].RXBUF_BADR = cpu_to_le32(virt_to_phys(skb->tail));
+				priv->rx_descs[cur_idx].VIR_RXBUF_BADR = cpu_to_le32((u32)skb->tail);
+			}
+
+			priv->rx_descs[cur_idx].RXPKT_RDY = RX_OWNBY_FTGMAC100;
+		}
+
+
+			//struct sk_buff *skb;
+			/* Dropped packets don't need to re-allocate */
+			if (priv->rx_skbuff[start_idx] == NULL) {
+				dma_addr_t mapping; 
+				skb = dev_alloc_skb(RX_BUF_SIZE + NET_IP_ALIGN);
+				if (skb == NULL) {
+					printk (KERN_INFO
+						"%s: receive_packet: "
+						"Unable to re-allocate Rx skbuff.#%d\n",
+						dev->name, cur_idx);
+				}
+				
+				skb_reserve(skb, NET_IP_ALIGN);
+				priv->rx_skbuff[start_idx] = skb;
+				skb->dev = dev;
+				mapping = dma_map_single(priv->dev, skb->data, skb->len, DMA_FROM_DEVICE);
+				priv->rx_descs[start_idx].RXBUF_BADR = cpu_to_le32(virt_to_phys(skb->tail));
+				priv->rx_descs[start_idx].VIR_RXBUF_BADR = cpu_to_le32((u32)skb->tail);
+			}
+
+
+		priv->rx_descs[start_idx].RXPKT_RDY = RX_OWNBY_FTGMAC100;
+	    }
+    }
+	if (trans_busy == 1)
+	{
+		/// priv->maccr_val |= RXMAC_EN_bit;
+		outl( priv->maccr_val, ioaddr + MACCR_REG );
+		outl( inl(ioaddr + IER_REG) | RXBUF_UNAVA_bit, ioaddr + IER_REG);
+	}
+	return;
+}
+
+/*--------------------------------------------------------------------
+ .
+ . This is the main routine of the driver, to handle the net_device when
+ . it needs some attention.
+ .
+ . So:
+ .   first, save state of the chipset
+ .   branch off into routines to handle each case, and acknowledge
+ .	    each to the interrupt register
+ .   and finally restore state.
+ .
+ ---------------------------------------------------------------------*/
+static irqreturn_t ftgmac100_interrupt(int irq, void * dev_id,  struct pt_regs * regs)
+{
+	struct net_device *dev 	= dev_id;
+	struct ftgmac100_priv *priv = (struct ftgmac100_priv *)dev->ml_priv;
+	unsigned long ioaddr 	= dev->base_addr;
+	int		timeout;
+	unsigned int tmp =0;
+	unsigned int	mask;			// interrupt mask
+	unsigned int	status;			// interrupt status
+
+//	PRINTK3("%s: ftgmac100 interrupt started \n", dev->name);
+
+	if (dev == NULL) {
+		DO_PRINT(KERN_WARNING "%s: irq %d for unknown device.\n",	dev->name, irq);
+		return IRQ_HANDLED;
+	}
+
+	/* read the interrupt status register */
+	mask = inl( ioaddr + IER_REG );
+
+	/* set a timeout value, so I don't stay here forever */
+
+	for (timeout=1; timeout>0; --timeout)
+	{
+		/* read the status flag, and mask it */
+		status = inl( ioaddr + ISR_REG ) & mask;
+
+		outl(status, ioaddr + ISR_REG ); //Richard, write to clear
+
+		if (!status )
+		{
+			break;
+		}
+
+		if (status & PHYSTS_CHG_bit) {
+		    PRINTK("PHYSTS_CHG \n");
+		    // Is this interrupt for changes of the PHYLINK pin?
+		    // Note: PHYLINK is optional; not all boards connect it.
+            if ((priv->ids.miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_KSZ9031)
+            {
+				PRINTK("%s: Interrupt from PHY PHYID_KSZ9031 ---\n", dev->name); // 20140625                
+            }
+            if (priv->ids.miiPhyId == PHYID_RTL8211FD)
+            {
+				PRINTK("%s: Interrupt from PHY PHYID_RTL8211FD ---\n", dev->name); // 20140625
+            }
+            else if (((priv->ids.miiPhyId & PHYID_VENDOR_MASK) == PHYID_VENDOR_MARVELL) || 
+		    	((priv->ids.miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8211))
+		    {
+			tmp = ftgmac100_read_phy_register(ioaddr, priv->ids.phyAddr, 0x13);
+			PRINTK("%s: PHY interrupt status, read_phy_reg(0x13) = 0x%04x\n",
+			       dev->name, tmp);
+			tmp &= (PHY_SPEED_CHG_bit | PHY_DUPLEX_CHG_bit | PHY_LINK_CHG_bit);
+		    }
+		    else if ((priv->ids.miiPhyId & PHYID_VENDOR_MASK) == PHYID_VENDOR_BROADCOM)
+		    {
+			tmp = ftgmac100_read_phy_register(ioaddr, priv->ids.phyAddr, 0x1a);
+			PRINTK("%s: PHY interrupt status, read_phy_reg(0x1a) = 0x%04x\n",
+			       dev->name, tmp);
+			// Bits [3:1] are {duplex, speed, link} change interrupts.
+			tmp &= 0x000e;
+		    }
+		    else if (priv->ids.miiPhyId == PHYID_BCM54612E) { 
+                tmp = ftgmac100_read_phy_register(ioaddr, priv->ids.phyAddr, 0x1A);
+                PRINTK("%s: PHY interrupt status, read_phy_reg(0x1A) = 0x%04x\n",
+                    dev->name, tmp);
+                tmp &= 0x000E;
+            }
+		    else tmp = 0;
+
+		    if (tmp) {
+			ftgmac100_reset(dev);
+			ftgmac100_enable(dev);
+		    }
+		}
+
+#ifdef not_complete_yet
+		if (status & AHB_ERR_bit)
+		{
+			DO_PRINT("AHB_ERR \n");
+		}
+
+		if (status & RPKT_LOST_bit)
+		{
+			DO_PRINT("RPKT_LOST ");
+		}
+		if (status & RPKT2F_bit)
+		{
+			PRINTK2("RPKT_SAV ");
+		}
+
+		if (status & TPKT_LOST_bit)
+		{
+			PRINTK("XPKT_LOST ");
+		}
+		if (status & TPKT2E_bit)
+		{
+			PRINTK("XPKT_OK ");
+		}
+		if (status & NPTXBUF_UNAVA_bit)
+		{
+			PRINTK("NOTXBUF ");
+		}
+		if (status & TPKT2F_bit)
+		{
+			PRINTK("XPKT_FINISH ");
+		}
+
+		if (status & RPKT2B_bit)
+		{
+			DO_PRINT("RPKT_FINISH ");
+		}
+		PRINTK2("\n");
+#endif /* end_of_not */
+
+//		PRINTK3(KERN_WARNING "%s: Handling interrupt status %x \n",	dev->name, status);
+
+		if ( status & (TPKT2E_bit|TPKT_LOST_bit))
+		{
+			//free tx skb buf
+			ftgmac100_free_tx(dev);
+
+		}
+
+		if ( status & RPKT2B_bit )
+		{
+            /* check WOL status register for magic packet */
+            if(inl(ioaddr + WOLSR_REG) & WOL_MAGICPKT_EN_bit)
+            {
+                /* clear WOL status register for magic packet bit
+                 * by setting the same bit */
+                outl((inl(ioaddr + WOLSR_REG) | WOL_MAGICPKT_EN_bit), ioaddr + WOLSR_REG);
+                /* we are inside interrupt handler, can't invoke
+                 * a user space program from here so initiate the
+                 * wakeup sequence via common kernel queue */
+                schedule_work(&(priv->wol_wakeup_work_queue));
+            }
+		
+		
+			ftgmac100_rcv(dev); //Richard
+		}
+		else if (status & RXBUF_UNAVA_bit)
+		{
+			outl( mask & ~RXBUF_UNAVA_bit, ioaddr + IER_REG);
+			trans_busy = 1;
+		/*
+			rcv_tq.sync = 0;
+			rcv_tq.routine = ftgmac100_rcv;
+			rcv_tq.data = dev;
+			queue_task(&rcv_tq, &tq_timer);
+		*/
+
+		} else if (status & AHB_ERR_bit)
+		{
+			DO_PRINT("AHB ERR \n");
+		}
+	}
+
+//	PRINTK3("%s: Interrupt done\n", dev->name);
+	return IRQ_HANDLED;
+}
+
+/*------------------------------------------------------------
+ . Get the current statistics.
+ . This may be called with the card open or closed.
+ .-------------------------------------------------------------*/
+static struct net_device_stats* ftgmac100_query_statistics(struct net_device *dev) 
+{
+	struct ftgmac100_priv *priv = (struct ftgmac100_priv *)dev->ml_priv;
+	
+	return &priv->stats;
+}
+
+#ifdef HAVE_MULTICAST
+
+// --------------------------------------------------------------------
+// 	Finds the CRC32 of a set of bytes.
+//	Again, from Peter Cammaert's code.
+// --------------------------------------------------------------------
+static int crc32( char * s, int length ) 
+{
+	/* indices */
+	int perByte;
+	int perBit;
+	/* crc polynomial for Ethernet */
+	const u32 poly = 0xedb88320;
+	/* crc value - preinitialized to all 1's */
+	u32 crc_value = 0xffffffff;
+
+	for ( perByte = 0; perByte < length; perByte ++ ) {
+		unsigned char	c;
+
+		c = *(s++);
+		for ( perBit = 0; perBit < 8; perBit++ ) {
+			crc_value = (crc_value>>1)^
+				(((crc_value^c)&0x01)?poly:0);
+			c >>= 1;
+		}
+	}
+	return	crc_value;
+}
+
+/*
+ . Function: ftgmac100_setmulticast( struct net_device *dev, int count, struct dev_mc_list * addrs )
+ . Purpose:
+ .    This sets the internal hardware table to filter out unwanted multicast
+ .    packets before they take up memory.
+*/
+
+static void ftgmac100_setmulticast( struct net_device *dev, int count, struct dev_mc_list * addrs ) 
+{
+	struct dev_mc_list	* cur_addr;
+	int crc_val;
+	unsigned int	ioaddr = dev->base_addr;
+	struct ftgmac100_priv *priv = (struct ftgmac100_priv *)dev->ml_priv;
+	struct AstMacHwConfig* ids = &priv->ids;
+	unsigned long Combined_Channel_ID, i;
+	struct sk_buff * skb;
+	cur_addr = addrs;	
+
+//TX
+	for (cur_addr = addrs ; cur_addr!=NULL ; cur_addr = cur_addr->next )
+	{
+		/* make sure this is a multicast address - shouldn't this be a given if we have it here ? */
+		if ( !( *cur_addr->dmi_addr & 1 ) )
+		{
+			continue;
+		}
+#if 1
+//A0, A1
+			crc_val = crc32( cur_addr->dmi_addr, 5 );
+			crc_val = (~(crc_val>>2)) & 0x3f;
+			if (crc_val >= 32)
+			{
+				outl(inl(ioaddr+MAHT1_REG) | (1UL<<(crc_val-32)), ioaddr+MAHT1_REG);
+				priv->GigaBit_MAHT1 = inl (ioaddr + MAHT1_REG);
+			}
+			else
+			{
+				outl(inl(ioaddr+MAHT0_REG) | (1UL<<crc_val), ioaddr+MAHT0_REG);
+				priv->GigaBit_MAHT0 = inl (ioaddr + MAHT0_REG);
+			}
+//10/100M
+			crc_val = crc32( cur_addr->dmi_addr, 6 );
+			crc_val = (~(crc_val>>2)) & 0x3f;
+			if (crc_val >= 32)
+			{
+				outl(inl(ioaddr+MAHT1_REG) | (1UL<<(crc_val-32)), ioaddr+MAHT1_REG);
+				priv->Not_GigaBit_MAHT1 = inl (ioaddr + MAHT1_REG);
+			}
+			else
+			{
+				outl(inl(ioaddr+MAHT0_REG) | (1UL<<crc_val), ioaddr+MAHT0_REG);
+				priv->Not_GigaBit_MAHT0 = inl (ioaddr + MAHT0_REG);
+			}
+#else
+//A2
+			crc_val = crc32( cur_addr->dmi_addr, 6 );
+			crc_val = (~(crc_val>>2)) & 0x3f;
+			if (crc_val >= 32)
+			{
+				outl(inl(ioaddr+MAHT1_REG) | (1UL<<(crc_val-32)), ioaddr+MAHT1_REG);
+				priv->Not_GigaBit_MAHT1 = inl (ioaddr + MAHT1_REG);
+				priv->GigaBit_MAHT1 = inl (ioaddr + MAHT1_REG);
+			}
+			else
+			{
+				outl(inl(ioaddr+MAHT0_REG) | (1UL<<crc_val), ioaddr+MAHT0_REG);
+				priv->Not_GigaBit_MAHT0 = inl (ioaddr + MAHT0_REG);
+				priv->GigaBit_MAHT0 = inl (ioaddr + MAHT0_REG);
+			}
+#endif
+	}
+}
+
+/*-----------------------------------------------------------
+ . ftgmac100_set_multicast_list
+ .
+ . This routine will, depending on the values passed to it,
+ . either make it accept multicast packets, go into
+ . promiscuous mode ( for TCPDUMP and cousins ) or accept
+ . a select set of multicast packets
+*/
+static void ftgmac100_set_multicast_list(struct net_device *dev)
+{
+	unsigned int ioaddr = dev->base_addr;
+	struct ftgmac100_priv *priv = (struct ftgmac100_priv *)dev->ml_priv;
+
+	PRINTK2("%s:ftgmac100_set_multicast_list\n", dev->name);
+
+	if (dev->flags & IFF_PROMISC)
+		priv->maccr_val |= RX_ALLADR_bit;
+	else
+		priv->maccr_val &= ~RX_ALLADR_bit;
+
+	if (dev->flags & IFF_ALLMULTI)
+		priv->maccr_val |= RX_MULTIPKT_bit;
+	else
+		priv->maccr_val &= ~RX_MULTIPKT_bit;
+
+	if (dev->mc_count)
+	{
+//		PRINTK("set multicast\n");
+		priv->maccr_val |= RX_HT_EN_bit;
+		ftgmac100_setmulticast( dev, dev->mc_count, dev->mc_list );
+	}
+	else
+	{
+		priv->maccr_val &= ~RX_HT_EN_bit;
+	}
+
+	outl( priv->maccr_val, ioaddr + MACCR_REG );
+
+}
+#endif
+
+static int ast_gmac_stop(struct net_device *dev)
+{
+	struct ftgmac100_priv *priv = (struct ftgmac100_priv *)dev->ml_priv;
+
+	netif_stop_queue(dev);
+
+	/* clear everything */
+	ftgmac100_shutdown(dev->base_addr);
+	free_irq(dev->irq, dev);
+
+	if (priv->timer.function != NULL) {
+	    del_timer_sync(&priv->timer);
+	}
+
+	if (priv->rx_descs)
+			dma_free_coherent( NULL, sizeof(RX_DESC)*RXDES_NUM, (void*)priv->rx_descs, (dma_addr_t)priv->rx_descs_dma );
+	if (priv->tx_descs)
+			dma_free_coherent( NULL, sizeof(TX_DESC)*TXDES_NUM, (void*)priv->tx_descs, (dma_addr_t)priv->tx_descs_dma );
+	if (priv->tx_buf)
+			dma_free_coherent( NULL, TX_BUF_SIZE*TXDES_NUM, (void*)priv->tx_buf, (dma_addr_t)priv->tx_buf_dma );
+	priv->rx_descs = NULL; priv->rx_descs_dma = 0;
+	priv->tx_descs = NULL; priv->tx_descs_dma = 0;
+	priv->tx_buf   = NULL; priv->tx_buf_dma   = 0;
+	
+
+	return 0;
+}
+
+#if 0
+static struct proc_dir_entry *proc_ftgmac100;
+
+static int ftgmac100_read_proc(char *page, char **start,  off_t off, int count, int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct ftgmac100_priv *priv 	= (struct ftgmac100_priv *)dev->ml_priv;
+	int num;
+	int i;
+
+	num = sprintf(page, "priv->rx_idx = %d\n", priv->rx_idx);
+	for (i=0; i<RXDES_NUM; ++i)
+	{
+		num += sprintf(page + num, "[%d].RXDMA_OWN = %d\n", i, priv->rx_descs[i].RXPKT_RDY);
+	}
+	return num;
+}
+#endif
+
+static int ftgmac100_open(struct net_device *netdev)
+{
+	struct ftgmac100_priv *priv = netdev_priv(netdev);
+	int err;
+
+	//DO_PRINT("%s:ftgmac100_open\n", netdev->name);
+
+/* initialise WOL wakeup work queue via
+     * common kernel work queue, once magic
+     * packet gets received schedule work on
+     * this queue to handle wakeup sequence */
+    INIT_WORK(&(priv->wol_wakeup_work_queue), wol_perform_wakeup);
+
+
+	priv->maccr_val = (CRC_APD_bit | RXMAC_EN_bit | TXMAC_EN_bit  | RXDMA_EN_bit | RX_MULTIPKT_bit
+			 | TXDMA_EN_bit | CRC_CHK_bit | RX_BROADPKT_bit | SPEED_100_bit | FULLDUP_bit);
+
+	ftgmac100_ringbuf_alloc(priv);
+
+
+	/* Grab the IRQ next.  Beyond this, we will free the IRQ. */
+	err = request_irq(netdev->irq, (void *)&ftgmac100_interrupt,
+			     IRQF_DISABLED, netdev->name, netdev);
+	if (err)
+	{
+		DO_PRINT("%s: unable to get IRQ %d (retval=%d).\n",
+			 netdev->name, netdev->irq, err);
+		kfree(netdev->ml_priv);
+		netdev->ml_priv = NULL;
+		return err;
+	}
+
+
+	netif_start_queue(netdev);
+
+	/* reset the hardware */
+	ftgmac100_reset(netdev);
+	ftgmac100_enable(netdev);
+
+//	if (((priv->ids.miiPhyId & PHYID_VENDOR_MASK) == PHYID_VENDOR_BROADCOM) || 
+//	    ((priv->ids.miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8201EL) ||
+//       (priv->ids.miiPhyId == PHYID_BCM54612E)) { 
+
+        init_timer(&priv->timer);
+	    priv->timer.data = (unsigned long)netdev;
+	    priv->timer.function = aspeed_mac_timer;
+	    priv->timer.expires = jiffies + 1 * HZ;
+	    add_timer (&priv->timer);
+//	}
+
+	/* Configure the PHY */
+	ftgmac100_phy_configure(netdev);
+
+	netif_start_queue(netdev);
+	return 0;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void ftgmac100_poll(struct net_device *dev)
+{
+    disable_irq(dev->irq);
+    ftgmac100_interrupt(dev->irq, dev);
+    enable_irq(dev->irq);
+}
+#endif
+
+/* Module Variables */
+static const struct net_device_ops ast_netdev_ops = {
+        ndo_open:               ftgmac100_open,
+        ndo_stop:               ast_gmac_stop,
+        ndo_start_xmit:         ftgmac100_wait_to_send_packet,
+        ndo_tx_timeout:         ftgmac100_timeout,
+        ndo_get_stats:          ftgmac100_query_statistics,
+#ifdef  HAVE_MULTICAST
+        ndo_set_multicast_list: ftgmac100_set_multicast_list,
+#endif
+#ifdef CONFIG_NET_POLL_CONTROLLER
+    ndo_poll_controller:  ftgmac100_poll,
+#endif
+	ndo_set_mac_address:	 eth_mac_addr,
+};
+
+
+static int ast_ether_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	   struct ftgmac100_priv *lp = netdev_priv(dev);
+       struct AstMacHwConfig* ids = &lp->ids;
+       unsigned long ioaddr = dev->base_addr;
+       uint32_t advert, bmcr, lpa, nego;
+       uint32_t advert2 = 0, bmcr2 = 0, lpa2 = 0;
+       
+       cmd->phy_address = 0;
+       cmd->supported = (SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full | SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
+                                       SUPPORTED_Autoneg | SUPPORTED_TP | SUPPORTED_MII | SUPPORTED_Pause);
+        cmd->supported |= SUPPORTED_1000baseT_Full;   /* Only support 1G full-duplex in ast2300/ast2400 and ast3100 */
+                         
+       cmd->transceiver = XCVR_INTERNAL; /* only supports internal transceiver */
+       cmd->advertising = ADVERTISED_TP | ADVERTISED_MII;
+
+       advert = ftgmac100_read_phy_register(ioaddr, ids->phyAddr, MII_ADVERTISE);
+       advert2 = ftgmac100_read_phy_register(ioaddr, ids->phyAddr, MII_CTRL1000);
+
+       if (advert & ADVERTISE_10HALF)
+               cmd->advertising |= ADVERTISED_10baseT_Half;
+       if (advert & ADVERTISE_10FULL)
+               cmd->advertising |= ADVERTISED_10baseT_Full;
+       if (advert & ADVERTISE_100HALF)
+               cmd->advertising |= ADVERTISED_100baseT_Half;
+       if (advert & ADVERTISE_100FULL)
+               cmd->advertising |= ADVERTISED_100baseT_Full;
+       if (advert2 & ADVERTISE_1000FULL)
+               cmd->advertising |= ADVERTISED_1000baseT_Full;
+                       
+       bmcr = ftgmac100_read_phy_register(ioaddr, ids->phyAddr, MII_BMCR);
+       lpa = ftgmac100_read_phy_register(ioaddr, ids->phyAddr, MII_LPA);
+       bmcr2 = ftgmac100_read_phy_register(ioaddr, ids->phyAddr, MII_CTRL1000);
+       lpa2 = ftgmac100_read_phy_register(ioaddr, ids->phyAddr, MII_STAT1000);
+
+       if (bmcr & BMCR_ANENABLE) {
+               cmd->autoneg = AUTONEG_ENABLE;
+               cmd->advertising |= ADVERTISED_Autoneg;
+				if (advert & ADVERTISE_PAUSE_CAP)
+					cmd->advertising |= ADVERTISED_Pause;
+				if (advert & ADVERTISE_PAUSE_ASYM)
+					cmd->advertising |= ADVERTISED_Asym_Pause;
+               nego = mii_nway_result(advert & lpa);
+
+           if ((bmcr2 & (ADVERTISE_1000HALF | ADVERTISE_1000FULL)) &
+                      (lpa2 >> 2))
+                       cmd->speed = SPEED_1000;
+           
+           else if (nego == LPA_100FULL || nego == LPA_100HALF)
+                       cmd->speed = SPEED_100;
+           else
+                       cmd->speed = SPEED_10;
+
+        if ((lpa2 & LPA_1000FULL) || nego == LPA_100FULL ||
+            nego == LPA_10FULL) 
+                       cmd->duplex = DUPLEX_FULL;
+               else
+                       cmd->duplex = DUPLEX_HALF;
+       } else {
+               cmd->autoneg = AUTONEG_DISABLE;
+
+        cmd->speed = ((bmcr & BMCR_SPEED1000 &&
+            (bmcr & BMCR_SPEED100) == 0) ? SPEED_1000 :
+                (bmcr & BMCR_SPEED100) ? SPEED_100 : SPEED_10);
+               cmd->duplex = (bmcr & BMCR_FULLDPLX) ? DUPLEX_FULL : DUPLEX_HALF;
+       }
+
+       return 0;
+}
+
+static int ast_ether_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	   struct ftgmac100_priv *lp = netdev_priv(dev);
+       struct AstMacHwConfig* ids = &lp->ids;
+       unsigned long ioaddr = dev->base_addr;
+       uint32_t bmcr, advert, tmp;
+       uint32_t advert2 = 0, tmp2 = 0;
+
+       ftgmac100_write_phy_register(ioaddr, ids->phyAddr, MII_BMCR, BMCR_RESET);
+
+       if (cmd->speed != SPEED_10 && 
+        cmd->speed != SPEED_100 &&
+        cmd->speed != SPEED_1000)
+               return -EINVAL;
+       if (cmd->duplex != DUPLEX_HALF && cmd->duplex != DUPLEX_FULL)
+               return -EINVAL;
+       if (cmd->autoneg != AUTONEG_DISABLE && cmd->autoneg != AUTONEG_ENABLE)
+               return -EINVAL;
+
+       if (cmd->autoneg == AUTONEG_ENABLE) {
+               if ((cmd->advertising & (ADVERTISED_10baseT_Half | 
+                                 ADVERTISED_10baseT_Full | 
+                                 ADVERTISED_100baseT_Half |
+                                 ADVERTISED_100baseT_Full | 
+                                 ADVERTISED_1000baseT_Half | 
+                                 ADVERTISED_1000baseT_Full)) == 0)
+                       return -EINVAL;
+
+               /* advertise only what has been requested */
+               advert = ftgmac100_read_phy_register(ioaddr, ids->phyAddr, MII_ADVERTISE);
+               tmp = advert & ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
+               
+               advert2 = ftgmac100_read_phy_register(ioaddr, ids->phyAddr, MII_CTRL1000);
+               tmp2 = advert2 & ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL);
+               
+               if (cmd->advertising & ADVERTISED_10baseT_Half)
+                       tmp |= ADVERTISE_10HALF;
+               if (cmd->advertising & ADVERTISED_10baseT_Full)
+                       tmp |= ADVERTISE_10FULL;
+               if (cmd->advertising & ADVERTISED_100baseT_Half)
+                       tmp |= ADVERTISE_100HALF;
+               if (cmd->advertising & ADVERTISED_100baseT_Full)
+                       tmp |= ADVERTISE_100FULL;
+                if (cmd->advertising & ADVERTISED_1000baseT_Half)
+             		   tmp2 |= ADVERTISE_1000HALF;
+                if (cmd->advertising & ADVERTISED_1000baseT_Full)
+                        tmp2 |= ADVERTISE_1000FULL;
+                tmp &= ~ADVERTISE_PAUSE_CAP;
+                tmp &= ~ADVERTISE_PAUSE_ASYM;
+		
+                if (cmd->advertising & ADVERTISED_Pause)
+                {			
+                    tmp |= ADVERTISE_PAUSE_CAP;
+                }			
+                if (cmd->advertising & ADVERTISED_Asym_Pause)
+                {			
+                    tmp |= ADVERTISE_PAUSE_ASYM;
+                }			
+
+               
+               if (advert != tmp) {
+                       ftgmac100_write_phy_register(ioaddr, ids->phyAddr, MII_ADVERTISE, tmp);
+               }
+               if ((advert2 != tmp2))
+                       ftgmac100_write_phy_register(ioaddr, ids->phyAddr, MII_CTRL1000, tmp2);
+                       
+               /* turn on auto negotiation, and force a re-negotiate */
+               bmcr = ftgmac100_read_phy_register(ioaddr, ids->phyAddr, MII_BMCR);
+               bmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);
+               ftgmac100_write_phy_register(ioaddr, ids->phyAddr, MII_BMCR, bmcr);
+       } else {
+        if ((cmd->speed == SPEED_1000) && (cmd->duplex == DUPLEX_HALF)) /* not supported */
+                return -EINVAL;
+               /* turn off auto negotiation, set speed and duplexity */
+               bmcr = ftgmac100_read_phy_register(ioaddr, ids->phyAddr, MII_BMCR);
+               tmp = bmcr & ~(BMCR_ANENABLE | BMCR_SPEED100 |
+                              BMCR_SPEED1000 | BMCR_FULLDPLX);
+
+        if (cmd->speed == SPEED_1000) {
+            tmp |= BMCR_SPEED1000;
+            tmp |= (BMCR_ANENABLE | BMCR_ANRESTART);  /* Don't know why connection lost if auto negotiation is off */
+        } else if (cmd->speed == SPEED_100)
+                       tmp |= BMCR_SPEED100;
+               if (cmd->duplex == DUPLEX_FULL)
+                       tmp |= BMCR_FULLDPLX;
+               if (bmcr != tmp)
+                       ftgmac100_write_phy_register(ioaddr, ids->phyAddr, MII_BMCR, tmp);
+       }
+
+       return 0;
+}
+
+static void ast_ether_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
+{
+    wol->supported |= WAKE_MAGIC;
+    wol->wolopts = 0;
+    if(inl(dev->base_addr + WOLCR_REG) & WOL_MAGICPKT_EN_bit)
+        wol->wolopts |= WAKE_MAGIC;
+}
+
+static int ast_ether_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
+{
+
+    if( wol->wolopts & (~WAKE_MAGIC) )
+        return -EOPNOTSUPP;
+    else if(wol->wolopts & WAKE_MAGIC)
+        enable_wol_magicpkt_detection(dev->base_addr);
+    else
+        disable_wol_magicpkt_detection(dev->base_addr);
+
+    return 0;
+}
+
+static u32 ast_ether_get_op_link(struct net_device *dev)
+{
+	struct ftgmac100_priv *priv = (struct ftgmac100_priv *)dev->ml_priv;
+	unsigned int status;
+	status = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x01);
+
+	return status & LINK_STATUS;
+}
+
+static void ast_ether_get_pauseparam(struct net_device *dev,
+		                                 struct ethtool_pauseparam *pause)
+{
+#if AST_PAUSE_FR_ENABLE	
+	struct ethtool_cmd ecmd;
+	memset (&ecmd, 0 , sizeof (struct ethtool_cmd));
+
+	ast_ether_get_settings(dev, &ecmd);
+	pause->autoneg  = ecmd.autoneg;
+
+	if (ecmd.advertising & ADVERTISED_Asym_Pause)
+	{		
+		if (ecmd.advertising & ADVERTISED_Pause)			
+		{			
+			pause->rx_pause = 1;
+			pause->tx_pause = 0;
+		}			
+		else
+		{			
+			pause->rx_pause = 0;
+			pause->tx_pause = 1;
+		}			
+
+	}		
+	else if (ecmd.advertising & ADVERTISED_Pause)
+	{		
+		pause->rx_pause = 1;
+		pause->tx_pause = 1;
+	}		
+	else
+	{
+		pause->rx_pause = 0;
+		pause->tx_pause = 0;
+	}
+#endif			
+}
+
+
+static int ast_ether_set_pauseparam(struct net_device *dev,
+		                                struct ethtool_pauseparam *pause)
+{
+#if AST_PAUSE_FR_ENABLE	
+	struct ftgmac100_priv *lp = netdev_priv(dev);
+	struct AstMacHwConfig* ids = &lp->ids;
+	struct ethtool_cmd ecmd;
+	uint32_t advert = 0, tmp;
+	unsigned int reg_value=0;
+	unsigned long ioaddr = dev->base_addr;
+
+	reg_value = inl(ioaddr + FCR_REG);
+	memset (&ecmd, 0 , sizeof (struct ethtool_cmd));
+	ast_ether_get_settings(dev, &ecmd);
+	if (ecmd.duplex == DUPLEX_FULL)
+	{
+		advert = ftgmac100_read_phy_register(ioaddr, ids->phyAddr, MII_ADVERTISE);
+		tmp=advert;
+		if (pause->rx_pause)
+		{			
+			if(pause->tx_pause)
+			{	
+				ecmd.advertising |= ADVERTISED_Pause;
+				ecmd.advertising &= ~ADVERTISED_Asym_Pause;
+				ast_ether_set_settings (dev, &ecmd);
+				reg_value |= 0x05;
+			}			
+			else
+			{
+				tmp |= ADVERTISE_PAUSE_CAP;
+	                        tmp |= ADVERTISE_PAUSE_ASYM;
+				reg_value |= 0x01;
+				reg_value &= ~0x04;
+			}
+		}			
+		else if (pause->tx_pause)
+		{
+			tmp &= ~ADVERTISE_PAUSE_CAP;
+	                tmp |= ADVERTISE_PAUSE_ASYM;
+			reg_value |= 0x05;
+		}			
+		else
+		{
+			ecmd.advertising &= ~ADVERTISED_Pause;
+			ecmd.advertising &= ~ADVERTISED_Asym_Pause;
+			ast_ether_set_settings (dev, &ecmd);
+			reg_value &= ~0x05;
+		}			
+		outl(reg_value, ioaddr + FCR_REG);
+		if (advert != tmp) {
+			ftgmac100_write_phy_register(ioaddr, ids->phyAddr, MII_ADVERTISE, tmp);
+		}
+	}	
+#endif	
+	return 0;			
+}	
+
+static const struct ethtool_ops ast_ether_ethtool_ops = {
+       .get_settings = ast_ether_get_settings,
+       .set_settings = ast_ether_set_settings,
+       .get_link = ast_ether_get_op_link,
+	   .get_wol = ast_ether_get_wol,
+       .set_wol = ast_ether_set_wol,
+       .set_pauseparam = ast_ether_set_pauseparam,
+       .get_pauseparam = ast_ether_get_pauseparam,
+};
+
+
+
+static int __init ast_gmac_probe(struct platform_device *pdev)
+{
+	int err;
+	struct resource *res;
+	struct net_device *netdev;
+	struct ftgmac100_priv *priv;
+	struct ftgmac100_eth_data *ast_eth_data = pdev->dev.platform_data;;
+
+	if (!pdev)
+		return -ENODEV;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENXIO;
+
+	/* setup net_device */
+	netdev = alloc_etherdev(sizeof(*priv));
+	if (!netdev) {
+		err = -ENOMEM;
+		goto err_alloc_etherdev;
+	}
+
+
+	netdev->irq = platform_get_irq(pdev, 0);
+	if (netdev->irq < 0) {
+		err = -ENXIO;
+		goto err_netdev;
+	}
+	SET_NETDEV_DEV(netdev, &pdev->dev);
+
+	netdev->ethtool_ops = &ast_ether_ethtool_ops;
+	
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30))
+	netdev->netdev_ops 			= &ast_netdev_ops;
+#else
+
+	ether_setup(netdev);
+
+	netdev->open				= ftgmac100_open;
+	netdev->stop				= ast_gmac_stop;
+	netdev->hard_start_xmit 	= ftgmac100_wait_to_send_packet;
+	netdev->tx_timeout 			= ftgmac100_timeout;
+	netdev->get_stats 			= ftgmac100_query_statistics;
+
+//#ifdef	HAVE_MULTICAST
+#if 0
+	netdev->set_multicast_list 	= &ftgmac100_set_multicast_list;
+#endif
+
+#endif
+	
+
+#ifdef CONFIG_AST_NPAI
+//	netdev->features = NETIF_F_GRO;
+//	netdev->features = NETIF_F_IP_CSUM | NETIF_F_GRO;
+#endif
+
+	platform_set_drvdata(pdev, netdev);
+
+	/* setup private data */
+	priv = netdev_priv(netdev);
+	priv->netdev = netdev;
+	priv->dev = &pdev->dev;
+	netdev->ml_priv = priv;
+	
+	priv->ids.macId = pdev->id;
+	
+	priv->linkstatus=0;
+
+	spin_lock_init(&priv->tx_lock);
+
+#ifdef USE_NAPI
+ 	/*initialize NAPI */
+	netif_napi_add(netdev, &priv->napi, ftgmac100_poll, 64);
+#endif
+	/* map io memory */
+	res = request_mem_region(res->start, resource_size(res),
+					   dev_name(&pdev->dev));
+	if (!res) {
+		dev_err(&pdev->dev, "Could not reserve memory region\n");
+		err = -ENOMEM;
+		goto err_req_mem;
+	}
+	PRINTK2("ast_gmac_probe 9\n");
+
+	netdev->base_addr = (u32)ioremap(res->start, resource_size(res));
+
+	if (!netdev->base_addr) {
+		dev_err(&pdev->dev, "Failed to ioremap ethernet registers\n");
+		err = -EIO;
+		goto err_ioremap;
+	}
+	PRINTK2("ast_gmac_probe 10\n");
+
+//	priv->irq = irq;
+#if 0//CONFIG_AST_MDIO
+	/* initialize mdio bus */
+	priv->mii_bus = mdiobus_alloc();
+	if (!priv->mii_bus) {
+		err = -EIO;
+		goto err_alloc_mdiobus;
+	}
+
+	priv->mii_bus->name = "ftgmac100_mdio";
+	snprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, "ftgmac100_mii.%d",pdev->id);
+
+	priv->mii_bus->priv = netdev;
+	priv->mii_bus->read = ftgmac100_mdiobus_read;
+	priv->mii_bus->write = ftgmac100_mdiobus_write;
+	priv->mii_bus->reset = ftgmac100_mdiobus_reset;
+	priv->mii_bus->irq = priv->phy_irq;
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		priv->mii_bus->irq[i] = PHY_POLL;
+
+	err = mdiobus_register(priv->mii_bus);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot register MDIO bus!\n");
+		goto err_register_mdiobus;
+	}
+
+	err = ftgmac100_mii_probe(priv);
+	if (err) {
+		dev_err(&pdev->dev, "MII Probe failed!\n");
+		goto err_mii_probe;
+	}
+#endif
+	PRINTK2("ast_gmac_probe 11\n");
+
+	/* register network device */
+	err = register_netdev(netdev);
+
+	PRINTK2("ast_gmac_probe 12\n");
+	
+	if (err) {
+		dev_err(&pdev->dev, "Failed to register netdev\n");
+		goto err_alloc_mdiobus;
+	}
+
+
+//	PRINTK2("irq %d, mapped at %x\n", netdev->irq, (u32)netdev->base_addr);
+
+//	memcpy(netdev->dev_addr,ast_eth_data->dev_addr,ETH_ALEN);
+	ast_ether_get_hardware_addr(netdev);
+
+//	if (!is_valid_ether_addr(netdev->dev_addr)) {
+//		random_ether_addr(netdev->dev_addr);
+//		printk("WARNING: AST_GMAC generated random MAC address %pM\n",
+//				netdev->dev_addr);
+//	}
+	printk("%s : MAC=%pM IO=0x%08lx IRQ=%d \n",netdev->name, netdev->dev_addr,netdev->base_addr,netdev->irq);
+#if 0
+	if ((proc_ftgmac100 = create_proc_entry( dev->name, 0, 0 )))
+	{
+		proc_ftgmac100->read_proc = ftgmac100_read_proc;
+		proc_ftgmac100->data = dev;
+		proc_ftgmac100->owner = THIS_MODULE;
+	}
+#endif
+	return 0;
+
+//err_register_netdev:
+//	phy_disconnect(priv->phydev);
+//err_mii_probe:
+//	mdiobus_unregister(priv->mii_bus);
+//err_register_mdiobus:
+//	mdiobus_free(priv->mii_bus);
+err_alloc_mdiobus:
+	iounmap((void __iomem *)netdev->base_addr);
+err_ioremap:
+	release_resource(res);
+err_req_mem:
+#ifdef USE_NAPI
+	netif_napi_del(&priv->napi);			
+#endif
+	platform_set_drvdata(pdev, NULL);
+err_netdev:	
+	free_netdev(netdev);
+err_alloc_etherdev:
+	return err;
+
+}
+
+static int  ast_gmac_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+//	struct ftgmac100_priv *priv = netdev_priv(dev);
+
+//	remove_proc_entry(dev->name, 0);
+
+	unregister_netdev(dev);
+
+#ifdef CONFIG_MII_PHY
+	phy_disconnect(priv->phydev);
+	mdiobus_unregister(priv->mii_bus);
+	mdiobus_free(priv->mii_bus);
+#endif
+
+	iounmap((void __iomem *)dev->base_addr);
+
+#ifdef CONFIG_AST_NPAI
+	netif_napi_del(&priv->napi);
+#endif
+
+	platform_set_drvdata(pdev, NULL);
+	free_netdev(dev);
+	return 0;
+}
+
+static struct platform_driver ast_gmac_driver = {
+	.remove		= ast_gmac_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+extern void __init ast_add_device_gmac(void);
+static int __init ast_gmac_init(void)
+{
+	printk("AST Ethernet Driver : Ver %s\n",DRV_VERSION);
+	ast_add_device_gmac();
+	return platform_driver_probe(&ast_gmac_driver, ast_gmac_probe);
+}
+
+static void __exit ast_gmac_exit(void)
+{
+	platform_driver_unregister(&ast_gmac_driver);
+}
+
+module_init(ast_gmac_init)
+module_exit(ast_gmac_exit)
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("ASPEED Technology Inc.");
+MODULE_DESCRIPTION("NIC driver for AST Series");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/aspeed/ast_gmac.h b/drivers/net/ethernet/aspeed/ast_gmac.h
new file mode 100644
index 0000000..2382455
--- /dev/null
+++ b/drivers/net/ethernet/aspeed/ast_gmac.h
@@ -0,0 +1,585 @@
+// --------------------------------------------------------------------
+
+#ifndef FTMAC100_H
+#define FTMAC100_H
+
+//#define HAVE_MULTICAST
+
+#define ISR_REG				0x00				// interrups status register
+#define IER_REG				0x04				// interrupt maks register
+#define MAC_MADR_REG		0x08				// MAC address (Most significant)
+#define MAC_LADR_REG		0x0c				// MAC address (Least significant)
+
+#define MAHT0_REG			0x10				// Multicast Address Hash Table 0 register
+#define MAHT1_REG			0x14				// Multicast Address Hash Table 1 register
+#define TXPD_REG			0x18				// Transmit Poll Demand register
+#define RXPD_REG			0x1c				// Receive Poll Demand register
+#define TXR_BADR_REG		0x20				// Transmit Ring Base Address register
+#define RXR_BADR_REG		0x24				// Receive Ring Base Address register
+
+#define HPTXPD_REG			0x28	//
+#define HPTXR_BADR_REG		0x2c	//
+
+#define ITC_REG				0x30				// interrupt timer control register
+#define APTC_REG			0x34				// Automatic Polling Timer control register
+#define DBLAC_REG			0x38				// DMA Burst Length and Arbitration control register
+
+#define DMAFIFOS_REG		0x3c	//
+#define FEAR_REG			0x44	//
+#define TPAFCR_REG			0x48	//
+#define RBSR_REG			0x4c	//for NC Body
+#define MACCR_REG			0x50				// MAC control register
+#define MACSR_REG			0x54				// MAC status register
+#define PHYCR_REG			0x60				// PHY control register
+#define PHYDATA_REG			0x64				// PHY Write Data register
+#define FCR_REG				0x68				// Flow Control register
+#define BPR_REG				0x6c				// back pressure register
+#define WOLCR_REG			0x70				// Wake-On-Lan control register
+#define WOLSR_REG			0x74				// Wake-On-Lan status register
+#define WFCRC_REG			0x78				// Wake-up Frame CRC register
+#define WFBM1_REG			0x80				// wake-up frame byte mask 1st double word register
+#define WFBM2_REG			0x84				// wake-up frame byte mask 2nd double word register
+#define WFBM3_REG			0x88				// wake-up frame byte mask 3rd double word register
+#define WFBM4_REG			0x8c				// wake-up frame byte mask 4th double word register
+
+#define NPTXR_PTR_REG		0x90	//
+#define HPTXR_PTR_REG		0x94	//
+#define RXR_PTR_REG			0x98	//
+
+
+// --------------------------------------------------------------------
+//		ISR_REG  IMR_REG 
+// --------------------------------------------------------------------
+#define HPTXBUF_UNAVA_bit	(1UL<<10)
+#define PHYSTS_CHG_bit		(1UL<<9)
+#define AHB_ERR_bit			(1UL<<8)
+#define TPKT_LOST_bit		(1UL<<7)
+#define NPTXBUF_UNAVA_bit	(1UL<<6)
+#define TPKT2F_bit			(1UL<<5)
+#define TPKT2E_bit			(1UL<<4)
+#define RPKT_LOST_bit		(1UL<<3)
+#define RXBUF_UNAVA_bit		(1UL<<2)
+#define RPKT2F_bit			(1UL<<1)
+#define RPKT2B_bit			(1UL<<0)
+
+
+// --------------------------------------------------------------------
+//	APTC_REG 
+// --------------------------------------------------------------------
+
+
+typedef struct
+{
+	u32 RXPOLL_CNT:4;
+	u32 RXPOLL_TIME_SEL:1;
+	u32 Reserved1:3;
+	u32 TXPOLL_CNT:4;
+	u32 TXPOLL_TIME_SEL:1;
+	u32 Reserved2:19;
+}FTGMAC100_APTCR_Status;
+
+// --------------------------------------------------------------------
+//		PHYCR_REG
+// --------------------------------------------------------------------
+#define PHY_RE_AUTO_bit			(1UL<<9)
+#define PHY_READ_bit			(1UL<<26)
+#define PHY_WRITE_bit			(1UL<<27)
+// --------------------------------------------------------------------
+//		PHYCR_REG 
+// --------------------------------------------------------------------
+#define PHY_AUTO_OK_bit			(1UL<<5)
+// --------------------------------------------------------------------
+//		PHY INT_STAT_REG 
+// --------------------------------------------------------------------
+#define PHY_SPEED_CHG_bit		(1UL<<14)
+#define PHY_DUPLEX_CHG_bit		(1UL<<13)
+#define PHY_LINK_CHG_bit		(1UL<<10)
+#define PHY_AUTO_COMP_bit		(1UL<<11)
+// --------------------------------------------------------------------
+//		PHY SPE_STAT_REG 
+// --------------------------------------------------------------------
+#define PHY_RESOLVED_bit		(1UL<<11)
+#define PHY_SPEED_mask			0xC000
+#define PHY_SPEED_10M			0x0
+#define PHY_SPEED_100M			0x1
+#define PHY_SPEED_1G			0x2
+#define PHY_DUPLEX_mask                 0x2000
+//#define PHY_FULLDUPLEX                  0x1
+#define PHY_SPEED_DUPLEX_MASK           0x01E0
+#define PHY_100M_DUPLEX                 0x0100
+#define PHY_100M_HALF                   0x0080
+#define PHY_10M_DUPLEX                  0x0040
+#define PHY_10M_HALF                    0x0020
+#define LINK_STATUS                     0x04
+
+// --------------------------------------------------------------------
+//      WOL*R_REG
+// --------------------------------------------------------------------
+#define WOL_MAGICPKT_EN_bit     (1UL<<2)
+
+
+
+
+// --------------------------------------------------------------------
+//		MACCR_REG
+// --------------------------------------------------------------------
+
+#define SW_RST_bit			(1UL<<31)				// software reset/
+#define DIRPATH_bit			(1UL<<21)
+#define RX_IPCS_FAIL_bit	(1UL<<20)	//
+#define SPEED_100_bit   	        (1UL<<19)	//
+#define RX_UDPCS_FAIL_bit	(1UL<<18)	//
+#define RX_BROADPKT_bit		(1UL<<17)				// Receiving broadcast packet
+#define RX_MULTIPKT_bit		(1UL<<16)				// receiving multicast packet
+#define RX_HT_EN_bit		(1UL<<15)
+#define RX_ALLADR_bit		(1UL<<14)				// not check incoming packet's destination address
+#define JUMBO_LF_bit		(1UL<<13)	//
+#define RX_RUNT_bit			(1UL<<12)				// Store incoming packet even its length is les than 64 byte
+#define CRC_CHK_bit			(1UL<<11)	//
+#define CRC_APD_bit			(1UL<<10)				// append crc to transmit packet
+#define GMAC_MODE_bit		(1UL<<9)	//
+#define FULLDUP_bit			(1UL<<8)				// full duplex
+#define ENRX_IN_HALFTX_bit	(1UL<<7)	//
+#define LOOP_EN_bit			(1UL<<6)				// Internal loop-back
+#define HPTXR_EN_bit		(1UL<<5)	//
+#define REMOVE_VLAN_bit		(1UL<<4)	//
+//#define MDC_SEL_bit		(1UL<<13)				// set MDC as TX_CK/10
+//#define RX_FTL_bit		(1UL<<11)				// Store incoming packet even its length is great than 1518 byte
+#define RXMAC_EN_bit		(1UL<<3)				// receiver enable
+#define TXMAC_EN_bit		(1UL<<2)				// transmitter enable
+#define RXDMA_EN_bit		(1UL<<1)				// enable DMA receiving channel
+#define TXDMA_EN_bit		(1UL<<0)				// enable DMA transmitting channel
+
+
+// --------------------------------------------------------------------
+//		SCU_REG
+// --------------------------------------------------------------------
+#define  SCU_PROTECT_KEY_REG                0x0
+#define  SCU_PROT_KEY_MAGIC                 0x1688a8a8
+#define  SCU_RESET_CONTROL_REG              0x04
+#define  SCU_RESET_MAC1                     (1u << 11)
+#define  SCU_RESET_MAC2                     (1u << 12)
+
+#define  SCU_HARDWARE_TRAPPING_REG          0x70
+#define  SCU_HT_MAC_INTF_LSBIT              6
+#define  SCU_HT_MAC_INTERFACE               (0x7u << SCU_HT_MAC_INTF_LSBIT)
+#define  MAC_INTF_SINGLE_PORT_MODES         (1u<<0/*GMII*/ | 1u<<3/*MII_ONLY*/ | 1u<<4/*RMII_ONLY*/)
+#define  SCU_HT_MAC_GMII                    0x0u
+// MII and MII mode
+#define  SCU_HT_MAC_MII_MII                 0x1u
+#define  SCU_HT_MAC_MII_ONLY                0x3u
+#define  SCU_HT_MAC_RMII_ONLY               0x4u
+
+/*
+SCU88 D[31]: MAC1 MDIO
+SCU88 D[30]: MAC1 MDC
+SCU90 D[2]:  MAC2 MDC/MDIO
+SCU80 D[0]:  MAC1 Link
+SCU80 D[1]:  MAC2 Link
+*/
+#define  SCU_MULTIFUNCTION_PIN_REG          0x74
+#define  SCU_MULTIFUNCTION_PIN_CTL1_REG     0x80
+#define  SCU_MULTIFUNCTION_PIN_CTL3_REG     0x88
+#define  SCU_MULTIFUNCTION_PIN_CTL5_REG     0x90
+#define  SCU_MFP_MAC2_PHYLINK               (1u << 1)
+#define  SCU_MFP_MAC1_PHYLINK               (1u << 0)
+#define  SCU_MFP_MAC2_MII_INTF              (1u << 21)
+#define  SCU_MFP_MAC2_MDC_MDIO              (1u << 2)
+#define  SCU_MFP_MAC1_MDIO                  (1u << 31)
+#define  SCU_MFP_MAC1_MDC                   (1u << 30)
+#define  SCU_SILICON_REVISION_REG           0x7C
+#define  SCU_SCRATCH_REG	            0x40
+
+
+
+// --------------------------------------------------------------------
+//		NCSI
+// --------------------------------------------------------------------
+
+//NCSI define & structure
+//NC-SI Command Packet
+typedef struct {
+//Ethernet Header
+    unsigned char  DA[6];
+    unsigned char  SA[6];
+    unsigned short EtherType;						//DMTF NC-SI
+//NC-SI Control Packet
+    unsigned char  MC_ID;						//Management Controller should set this field to 0x00
+    unsigned char  Header_Revision;					//For NC-SI 1.0 spec, this field has to set 0x01
+    unsigned char  Reserved_1;						//Reserved has to set to 0x00
+    unsigned char  IID;							//Instance ID
+    unsigned char  Command;
+    unsigned char  Channel_ID;
+    unsigned short Payload_Length;					//Payload Length = 12 bits, 4 bits are reserved
+    unsigned long  Reserved_2;
+    unsigned long  Reserved_3;
+}  NCSI_Command_Packet;
+
+//Command and Response Type
+#define	CLEAR_INITIAL_STATE			0x00			//M
+#define	SELECT_PACKAGE				0x01			//M
+#define	DESELECT_PACKAGE			0x02			//M
+#define	ENABLE_CHANNEL				0x03			//M
+#define	DISABLE_CHANNEL				0x04			//M
+#define	RESET_CHANNEL				0x05			//M
+#define	ENABLE_CHANNEL_NETWORK_TX		0x06			//M
+#define	DISABLE_CHANNEL_NETWORK_TX		0x07			//M
+#define	AEN_ENABLE				0x08
+#define	SET_LINK				0x09			//M
+#define	GET_LINK_STATUS				0x0A			//M
+#define	SET_VLAN_FILTER				0x0B			//M
+#define	ENABLE_VLAN				0x0C			//M
+#define	DISABLE_VLAN				0x0D			//M
+#define	SET_MAC_ADDRESS				0x0E			//M
+#define	ENABLE_BROADCAST_FILTERING		0x10			//M
+#define	DISABLE_BROADCAST_FILTERING		0x11			//M
+#define	ENABLE_GLOBAL_MULTICAST_FILTERING	0x12
+#define	DISABLE_GLOBAL_MULTICAST_FILTERING	0x13
+#define	SET_NCSI_FLOW_CONTROL			0x14
+#define	GET_VERSION_ID				0x15			//M
+#define	GET_CAPABILITIES			0x16			//M
+#define	GET_PARAMETERS				0x17			//M
+#define	GET_CONTROLLER_PACKET_STATISTICS	0x18
+#define	GET_NCSI_STATISTICS			0x19
+#define	GET_NCSI_PASS_THROUGH_STATISTICS	0x1A
+
+//NC-SI Response Packet
+typedef struct {
+    unsigned char  DA[6];
+    unsigned char  SA[6];
+    unsigned short EtherType;						//DMTF NC-SI
+//NC-SI Control Packet
+    unsigned char  MC_ID;						//Management Controller should set this field to 0x00
+    unsigned char  Header_Revision;					//For NC-SI 1.0 spec, this field has to set 0x01
+    unsigned char  Reserved_1;						//Reserved has to set to 0x00
+    unsigned char  IID;							//Instance ID
+    unsigned char  Command;
+    unsigned char  Channel_ID;
+    unsigned short Payload_Length;					//Payload Length = 12 bits, 4 bits are reserved
+    unsigned short  Reserved_2;
+    unsigned short  Reserved_3;
+    unsigned short  Reserved_4;
+    unsigned short  Reserved_5;
+    unsigned short  Response_Code;
+    unsigned short  Reason_Code;
+    unsigned char   Payload_Data[64];
+}  NCSI_Response_Packet;
+
+//Standard Response Code
+#define	COMMAND_COMPLETED			0x00
+#define	COMMAND_FAILED				0x01
+#define	COMMAND_UNAVAILABLE			0x02
+#define	COMMAND_UNSUPPORTED			0x03
+
+//Standard Reason Code
+#define	NO_ERROR				0x0000
+#define	INTERFACE_INITIALIZATION_REQUIRED	0x0001
+#define	PARAMETER_IS_INVALID			0x0002
+#define	CHANNEL_NOT_READY			0x0003
+#define	PACKAGE_NOT_READY			0x0004
+#define	INVALID_PAYLOAD_LENGTH			0x0005
+#define	UNKNOWN_COMMAND_TYPE			0x7FFF
+
+
+struct AEN_Packet {
+//Ethernet Header
+    unsigned char  DA[6];
+    unsigned char  SA[6];						//Network Controller SA = FF:FF:FF:FF:FF:FF
+    unsigned short EtherType;						//DMTF NC-SI
+//AEN Packet Format
+    unsigned char  MC_ID;						//Network Controller should set this field to 0x00
+    unsigned char  Header_Revision;					//For NC-SI 1.0 spec, this field has to set 0x01
+    unsigned char  Reserved_1;						//Reserved has to set to 0x00
+//    unsigned char  IID = 0x00;						//Instance ID = 0 in Network Controller
+//    unsigned char  Command = 0xFF;					//AEN = 0xFF
+    unsigned char  Channel_ID;
+//    unsigned short Payload_Length = 0x04;				//Payload Length = 4 in Network Controller AEN Packet
+    unsigned long  Reserved_2;
+    unsigned long  Reserved_3;
+    unsigned char  AEN_Type;
+//    unsigned char  Reserved_4[3] = {0x00, 0x00, 0x00};
+    unsigned long  Optional_AEN_Data;
+    unsigned long  Payload_Checksum;
+};
+
+//AEN Type
+#define	LINK_STATUS_CHANGE			0x0
+#define	CONFIGURATION_REQUIRED			0x1
+#define	HOST_NC_DRIVER_STATUS_CHANGE		0x2
+
+typedef struct {
+	unsigned char Package_ID;
+	unsigned char Channel_ID;
+	unsigned long Capabilities_Flags;
+	unsigned long Broadcast_Packet_Filter_Capabilities;
+	unsigned long Multicast_Packet_Filter_Capabilities;
+	unsigned long Buffering_Capabilities;
+	unsigned long AEN_Control_Support;
+} NCSI_Capability;
+
+//SET_MAC_ADDRESS
+#define UNICAST		(0x00 << 5)
+#define MULTICAST_ADDRESS	(0x01 << 5)
+#define DISABLE_MAC_ADDRESS_FILTER	0x00
+#define ENABLE_MAC_ADDRESS_FILTER	0x01
+
+//GET_LINK_STATUS
+#define LINK_DOWN	0
+#define LINK_UP		1
+
+#define NCSI_LOOP   1500000
+#define RETRY_COUNT     1
+
+#define NCSI_HEADER	0xF888		//Reversed because of 0x88 is low byte, 0xF8 is high byte in memory
+
+// --------------------------------------------------------------------
+//		Receive Ring descriptor structure
+// --------------------------------------------------------------------
+
+typedef struct
+{
+	// RXDES0
+	u32 VDBC:14;//0~10
+	u32 Reserved1:1;          //11~15
+	u32 Reserved3:1;
+	u32 MULTICAST:1;          //16
+	u32 BROADCAST:1;          //17
+	u32 RX_ERR:1;             //18
+	u32 CRC_ERR:1;            //19
+	u32 FTL:1;
+	u32 RUNT:1;
+	u32 RX_ODD_NB:1;
+	u32 FIFO_FULL:1;
+	u32 PAUSE_OPCODE:1;
+	u32 PAUSE_FRAME:1;
+	u32 Reserved2:2;
+	u32 LRS:1;
+	u32 FRS:1;
+	u32 EDORR:1;
+	u32 RXPKT_RDY:1;		// 1 ==> owned by FTMAC100, 0 ==> owned by software
+	
+	// RXDES1
+	u32 VLAN_TAGC:16;
+	u32 Reserved4:4;
+	u32 PROTL_TYPE:2;
+	u32 LLC_PKT:1;
+	u32 DF:1;
+	u32 VLAN_AVA:1;	
+	u32 TCPCS_FAIL:1;
+	u32 UDPCS_FAIL:1;
+	u32 IPCS_FAIL:1;
+	u32 Reserved5:4;
+	
+	// RXDES2
+	u32 Reserved6:32;
+	
+	// RXDES3
+	u32 RXBUF_BADR;
+				
+	u32 VIR_RXBUF_BADR;			// not defined, the virtual address of receive buffer is placed here
+	
+	u32 RESERVED; 
+	u32 RESERVED1; 
+	u32 RESERVED2;	
+}RX_DESC;
+
+
+typedef struct
+{
+	// TXDES0
+	u32 TXBUF_Size:14;
+	u32 Reserved1:1;
+	u32 Reserved2:1;
+	u32 Reserved3:3;
+	u32 CRC_ERR:1;
+	u32 Reserved4:8;
+	u32 LTS:1;
+	u32 FTS:1;
+	u32 EDOTR:1;
+	u32 TXDMA_OWN:1;
+	
+	// TXDES1
+	u32 VLAN_TAGC:16;
+	u32 INS_VLAN:1;
+	u32 TCPCS_EN:1;
+	u32 UDPCS_EN:1;
+	u32 IPCS_EN:1;
+	u32 Reserved5:2;
+	u32 LLC_PKT:1;
+	u32 Reserved6:7;
+	u32 TX2FIC:1;
+	u32 TXIC:1;	
+	
+	// TXDES2
+	u32 Reserved7:32;
+
+	// TXDES3
+	u32 TXBUF_BADR;
+
+	u32 VIR_TXBUF_BADR;			// Reserve, the virtual address of transmit buffer is placed here
+
+	u32 RESERVED;
+	u32 RESERVED1; 
+	u32 RESERVED2; 
+
+}TX_DESC;
+
+
+
+// waiting to do:
+#define	TXPOLL_CNT			8
+#define RXPOLL_CNT			0
+
+#define TX_OWNBY_SOFTWARE		0
+#define TX_OWNBY_FTGMAC100		1
+
+
+#define RX_OWNBY_SOFTWARE		1
+#define RX_OWNBY_FTGMAC100		0
+
+// --------------------------------------------------------------------
+//		driver related definition
+// --------------------------------------------------------------------
+
+
+//#define RXDES_NUM			64//64 // we defined 32 descriptor for OTG issue 
+#define RXDES_NUM			32
+
+#define RX_BUF_SIZE			1536
+
+#define TXDES_NUM			32
+#define TX_BUF_SIZE			1536
+
+#define PHYID_VENDOR_MASK               0xfffffc00
+#define PHYID_VENDOR_MODEL_MASK         0xfffffff0
+#define PHYID_MODEL_MASK                0x000003f0
+#define PHYID_REVISION_MASK             0x0000000f
+#define PHYID_VENDOR_MARVELL            0x01410c00
+#define PHYID_VENDOR_BROADCOM           0x00406000
+#define PHYID_VENDOR_REALTEK            0x001cc800
+#define PHYID_VENDOR_MICREL             0x00221400
+
+#define PHYID_BCM5221A4                 0x004061e4
+//#define PHYID_RTL8201EL                 0x001cc815
+#define PHYID_RTL8201EL					0x001cc810
+#define PHYID_RTL8201F                  0x001cc816
+#define PHYID_RTL8211                   0x001cc910
+#define PHYID_RTL8211E                  0x001cc915
+#define PHYID_RTL8211FD                 0x001cc916
+#define PHYID_BCM54612E                 0x03625E6A
+#define PHYID_KSZ9031                   0x00221620
+
+/* store this information for the driver.. */
+
+struct AstMacHwConfig {
+    unsigned char phyAddr;	// See IP_phy_addr[] encoding
+    unsigned char macId;
+    unsigned char isRevA0;
+    unsigned char isRevA2;
+    unsigned char pad[1];
+    unsigned int  miiPhyId;
+};
+
+struct ftgmac100_priv {
+
+ 	// these are things that the kernel wants me to keep, so users
+	// can find out semi-useless statistics of how well the card is
+	// performing
+	struct net_device_stats stats;
+
+	struct AstMacHwConfig ids;
+
+	struct net_device *netdev;
+	struct device *dev;
+
+	// Set to true during the auto-negotiation sequence
+	int	autoneg_active;
+
+	// Last contents of PHY Register 18
+	u32		lastPhy18;
+
+	spinlock_t tx_lock;
+
+	//RX ..
+	volatile RX_DESC *rx_descs;			// receive ring base address
+	struct sk_buff *rx_skbuff[RXDES_NUM];
+	u32		rx_descs_dma;				// receive ring physical base address
+	int		rx_idx;						// receive descriptor
+
+	//TX ..
+	volatile TX_DESC *tx_descs;
+	u32		tx_descs_dma;
+	char	*tx_buf;
+	int		tx_buf_dma;
+	int		tx_idx;
+	int		old_tx;
+	struct sk_buff *tx_skbuff[TXDES_NUM];
+	
+	int     maccr_val;
+        struct timer_list    timer;
+	u32		GigaBit_MAHT0;
+	u32		GigaBit_MAHT1;
+	u32		Not_GigaBit_MAHT0;
+	u32		Not_GigaBit_MAHT1;
+	NCSI_Command_Packet NCSI_Request;
+	NCSI_Response_Packet NCSI_Respond;
+	NCSI_Capability NCSI_Cap;
+	unsigned int 	InstanceID;
+	unsigned int 	Retry;
+	unsigned char	Payload_Data[16];
+	unsigned char	Payload_Pad[4];
+	unsigned long	Payload_Checksum;
+	int		tx_free;
+	unsigned long	NCSI_support;
+	unsigned long	INTEL_NCSI_EVA_support;
+	int  linkstatus;
+
+	struct work_struct wol_wakeup_work_queue;
+	struct napi_struct napi;
+};
+
+
+#define FTGMAC100_STROBE_TIME			(10*HZ)
+///#define FTMAC100_STROBE_TIME			1
+
+//I2C define for EEPROM
+#define    AC_TIMING        0x77743335
+#define    ALL_CLEAR        0xFFFFFFFF
+#define    MASTER_ENABLE    0x01
+#define    SLAVE_ENABLE     0x02
+#define    LOOP_COUNT       0x100000
+
+
+#define    I2C_BASE                         0x1e78A000
+#define    I2C_FUNCTION_CONTROL_REGISTER    0x00
+#define    I2C_AC_TIMING_REGISTER_1         0x04
+#define    I2C_AC_TIMING_REGISTER_2         0x08
+#define    I2C_INTERRUPT_CONTROL_REGISTER   0x0C
+#define    I2C_INTERRUPT_STATUS_REGISTER    0x10
+#define    I2C_COMMAND_REGISTER             0x14
+#define    I2C_BYTE_BUFFER_REGISTER         0x20
+
+
+#define    MASTER_START_COMMAND    (1 << 0)
+#define    MASTER_TX_COMMAND       (1 << 1)
+#define    MASTER_RX_COMMAND       (1 << 3)
+#define    RX_COMMAND_LIST         (1 << 4)
+#define    MASTER_STOP_COMMAND     (1 << 5)
+
+#define    TX_ACK       (1 << 0)
+#define    TX_NACK      (1 << 1)
+#define    RX_DONE      (1 << 2)
+#define    STOP_DONE    (1 << 4)
+
+struct ftgmac100_eth_data
+{
+    unsigned char   dev_addr[6];    //MAC address
+    unsigned char   phy_addr;       //Phy Address
+    unsigned char   phy_id;         //Phy ID
+};
+
+#define AST_PAUSE_FR_ENABLE 1
+ 
+#endif  /* _SMC_91111_H_ */
+
+
diff --git a/drivers/net/ethernet/aspeed/dev-eth.c b/drivers/net/ethernet/aspeed/dev-eth.c
new file mode 100644
index 0000000..5d39e7d
--- /dev/null
+++ b/drivers/net/ethernet/aspeed/dev-eth.c
@@ -0,0 +1,114 @@
+/********************************************************************************
+* File Name     : linux/arch/arm/plat-aspeed/dev-eth.c
+* Author        : Ryan Chen
+* Description   : Aspeed Ethernet Device
+*
+* Copyright (C) ASPEED Technology Inc.
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by the Free Software Foundation;
+* either version 2 of the License, or (at your option) any later version.
+* 
+* This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* 
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*   History      :
+*    1. 2012/08/24 Ryan Chen initial
+*
+********************************************************************************/
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+#include <linux/etherdevice.h>
+
+#include <mach/irqs.h>
+#include <mach/platform.h>
+#include "ast_gmac.h"
+
+extern unsigned long enetaddr[][6];
+
+static struct ftgmac100_eth_data ast_eth0_data = 
+{
+	.dev_addr = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},		
+};
+
+static u64 ast_eth_dmamask = 0xffffffffUL;
+static struct resource ast_mac0_resources[] = 
+{
+	[0] = {
+		.start = AST_MAC1_BASE,
+		.end = AST_MAC1_BASE + SZ_128K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_MAC1,
+		.end = IRQ_MAC1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device ast_eth0_device = 
+{
+	.name		= "astgmac",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &ast_eth_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+				.platform_data = &ast_eth0_data,
+	},
+	.resource	= ast_mac0_resources,
+	.num_resources = ARRAY_SIZE(ast_mac0_resources),
+};
+
+#if (CONFIG_SPX_FEATURE_GLOBAL_NIC_COUNT > 1)	
+static struct ftgmac100_eth_data ast_eth1_data = 
+{
+	.dev_addr = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},		
+};
+
+static struct resource ast_mac1_resources[] = 
+{
+	[0] = {
+		.start = AST_MAC2_BASE,
+		.end = AST_MAC2_BASE + SZ_128K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_MAC2,
+		.end = IRQ_MAC2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device ast_eth1_device = 
+{
+	.name		= "astgmac",
+	.id		= 1,
+	.dev		= {
+				.dma_mask		= &ast_eth_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+				.platform_data = &ast_eth1_data,
+	},
+	.resource	= ast_mac1_resources,
+	.num_resources = ARRAY_SIZE(ast_mac1_resources),
+};
+#endif
+
+
+void __init ast_add_device_gmac(void)
+{
+
+	memcpy(ast_eth0_data.dev_addr, enetaddr[0], ETH_ALEN);
+	platform_device_register(&ast_eth0_device);
+
+
+#if (CONFIG_SPX_FEATURE_GLOBAL_NIC_COUNT > 1)	
+	memcpy(ast_eth1_data.dev_addr, enetaddr[1], ETH_ALEN);
+	platform_device_register(&ast_eth1_device);
+#endif
+}
+
diff --git a/drivers/net/ethernet/aspeed/ftgmac100.c b/drivers/net/ethernet/aspeed/ftgmac100.c
new file mode 100644
index 0000000..ac4fae7
--- /dev/null
+++ b/drivers/net/ethernet/aspeed/ftgmac100.c
@@ -0,0 +1,1379 @@
+/*
+ * Faraday FTGMAC100 Gigabit Ethernet
+ *
+ * (C) Copyright 2009-2011 Faraday Technology
+ * Po-Yu Chuang <ratbert@faraday-tech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+ /* AMI: Modfied for AST SOC Series for SPX Stack */
+
+#define pr_fmt(fmt)	KBUILD_MODNAME ": " fmt
+
+#include <linux/dma-mapping.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <net/ip.h>
+
+#include "ftgmac100.h"
+
+#define DRV_NAME	"astgmac"
+#define DRV_VERSION	"0.7"
+
+#define RX_QUEUE_ENTRIES	256	/* must be power of 2 */
+#define TX_QUEUE_ENTRIES	512	/* must be power of 2 */
+
+#define MAX_PKT_SIZE		1518
+#define RX_BUF_SIZE		PAGE_SIZE	/* must be smaller than 0x3fff */
+
+/******************************************************************************
+ * private data
+ *****************************************************************************/
+struct ftgmac100_descs {
+	struct ftgmac100_rxdes rxdes[RX_QUEUE_ENTRIES];
+	struct ftgmac100_txdes txdes[TX_QUEUE_ENTRIES];
+};
+
+struct ftgmac100 {
+	struct resource *res;
+	void __iomem *base;
+	int irq;
+
+	struct ftgmac100_descs *descs;
+	dma_addr_t descs_dma_addr;
+
+	unsigned int rx_pointer;
+	unsigned int tx_clean_pointer;
+	unsigned int tx_pointer;
+	unsigned int tx_pending;
+
+	spinlock_t tx_lock;
+
+	struct net_device *netdev;
+	struct device *dev;
+	struct napi_struct napi;
+
+	struct mii_bus *mii_bus;
+	int phy_irq[PHY_MAX_ADDR];
+	struct phy_device *phydev;
+	int old_speed;
+};
+
+static int ftgmac100_alloc_rx_page(struct ftgmac100 *priv,
+				   struct ftgmac100_rxdes *rxdes, gfp_t gfp);
+
+/******************************************************************************
+ * internal functions (hardware register access)
+ *****************************************************************************/
+#define INT_MASK_ALL_ENABLED	(FTGMAC100_INT_RPKT_LOST	| \
+				 FTGMAC100_INT_XPKT_ETH		| \
+				 FTGMAC100_INT_XPKT_LOST	| \
+				 FTGMAC100_INT_AHB_ERR		| \
+				 FTGMAC100_INT_RPKT_BUF		| \
+				 FTGMAC100_INT_NO_RXBUF)
+
+static void ftgmac100_set_rx_ring_base(struct ftgmac100 *priv, dma_addr_t addr)
+{
+	iowrite32(addr, priv->base + FTGMAC100_OFFSET_RXR_BADR);
+}
+
+static void ftgmac100_set_rx_buffer_size(struct ftgmac100 *priv,
+		unsigned int size)
+{
+	size = FTGMAC100_RBSR_SIZE(size);
+	iowrite32(size, priv->base + FTGMAC100_OFFSET_RBSR);
+}
+
+static void ftgmac100_set_normal_prio_tx_ring_base(struct ftgmac100 *priv,
+						   dma_addr_t addr)
+{
+	iowrite32(addr, priv->base + FTGMAC100_OFFSET_NPTXR_BADR);
+}
+
+static void ftgmac100_txdma_normal_prio_start_polling(struct ftgmac100 *priv)
+{
+	iowrite32(1, priv->base + FTGMAC100_OFFSET_NPTXPD);
+}
+
+static int ftgmac100_reset_hw(struct ftgmac100 *priv)
+{
+	struct net_device *netdev = priv->netdev;
+	int i;
+
+	/* NOTE: reset clears all registers */
+	iowrite32(FTGMAC100_MACCR_SW_RST, priv->base + FTGMAC100_OFFSET_MACCR);
+	for (i = 0; i < 5; i++) {
+		unsigned int maccr;
+
+		maccr = ioread32(priv->base + FTGMAC100_OFFSET_MACCR);
+		if (!(maccr & FTGMAC100_MACCR_SW_RST))
+			return 0;
+
+		udelay(1000);
+	}
+
+	netdev_err(netdev, "software reset failed\n");
+	return -EIO;
+}
+
+static void ftgmac100_set_mac(struct ftgmac100 *priv, const unsigned char *mac)
+{
+	unsigned int maddr = mac[0] << 8 | mac[1];
+	unsigned int laddr = mac[2] << 24 | mac[3] << 16 | mac[4] << 8 | mac[5];
+
+	iowrite32(maddr, priv->base + FTGMAC100_OFFSET_MAC_MADR);
+	iowrite32(laddr, priv->base + FTGMAC100_OFFSET_MAC_LADR);
+}
+
+static void ftgmac100_init_hw(struct ftgmac100 *priv)
+{
+	/* setup ring buffer base registers */
+	ftgmac100_set_rx_ring_base(priv,
+				   priv->descs_dma_addr +
+				   offsetof(struct ftgmac100_descs, rxdes));
+	ftgmac100_set_normal_prio_tx_ring_base(priv,
+					       priv->descs_dma_addr +
+					       offsetof(struct ftgmac100_descs, txdes));
+
+	ftgmac100_set_rx_buffer_size(priv, RX_BUF_SIZE);
+
+	iowrite32(FTGMAC100_APTC_RXPOLL_CNT(1), priv->base + FTGMAC100_OFFSET_APTC);
+
+	ftgmac100_set_mac(priv, priv->netdev->dev_addr);
+}
+
+#define MACCR_ENABLE_ALL	(FTGMAC100_MACCR_TXDMA_EN	| \
+				 FTGMAC100_MACCR_RXDMA_EN	| \
+				 FTGMAC100_MACCR_TXMAC_EN	| \
+				 FTGMAC100_MACCR_RXMAC_EN	| \
+				 FTGMAC100_MACCR_FULLDUP	| \
+				 FTGMAC100_MACCR_CRC_APD	| \
+				 FTGMAC100_MACCR_RX_RUNT	| \
+				 FTGMAC100_MACCR_RX_BROADPKT)
+
+static void ftgmac100_start_hw(struct ftgmac100 *priv, int speed)
+{
+	int maccr = MACCR_ENABLE_ALL;
+
+	switch (speed) {
+	default:
+	case 10:
+		break;
+
+	case 100:
+		maccr |= FTGMAC100_MACCR_FAST_MODE;
+		break;
+
+	case 1000:
+		maccr |= FTGMAC100_MACCR_GIGA_MODE;
+		break;
+	}
+
+	iowrite32(maccr, priv->base + FTGMAC100_OFFSET_MACCR);
+}
+
+static void ftgmac100_stop_hw(struct ftgmac100 *priv)
+{
+	iowrite32(0, priv->base + FTGMAC100_OFFSET_MACCR);
+}
+
+/******************************************************************************
+ * internal functions (receive descriptor)
+ *****************************************************************************/
+static bool ftgmac100_rxdes_first_segment(struct ftgmac100_rxdes *rxdes)
+{
+	return rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_FRS);
+}
+
+static bool ftgmac100_rxdes_last_segment(struct ftgmac100_rxdes *rxdes)
+{
+	return rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_LRS);
+}
+
+static bool ftgmac100_rxdes_packet_ready(struct ftgmac100_rxdes *rxdes)
+{
+	return rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_RXPKT_RDY);
+}
+
+static void ftgmac100_rxdes_set_dma_own(struct ftgmac100_rxdes *rxdes)
+{
+	/* clear status bits */
+	rxdes->rxdes0 &= cpu_to_le32(FTGMAC100_RXDES0_EDORR);
+}
+
+static bool ftgmac100_rxdes_rx_error(struct ftgmac100_rxdes *rxdes)
+{
+	return rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_RX_ERR);
+}
+
+static bool ftgmac100_rxdes_crc_error(struct ftgmac100_rxdes *rxdes)
+{
+	return rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_CRC_ERR);
+}
+
+static bool ftgmac100_rxdes_frame_too_long(struct ftgmac100_rxdes *rxdes)
+{
+	return rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_FTL);
+}
+
+static bool ftgmac100_rxdes_runt(struct ftgmac100_rxdes *rxdes)
+{
+	return rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_RUNT);
+}
+
+static bool ftgmac100_rxdes_odd_nibble(struct ftgmac100_rxdes *rxdes)
+{
+	return rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_RX_ODD_NB);
+}
+
+static unsigned int ftgmac100_rxdes_data_length(struct ftgmac100_rxdes *rxdes)
+{
+	return le32_to_cpu(rxdes->rxdes0) & FTGMAC100_RXDES0_VDBC;
+}
+
+static bool ftgmac100_rxdes_multicast(struct ftgmac100_rxdes *rxdes)
+{
+	return rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_MULTICAST);
+}
+
+static void ftgmac100_rxdes_set_end_of_ring(struct ftgmac100_rxdes *rxdes)
+{
+	rxdes->rxdes0 |= cpu_to_le32(FTGMAC100_RXDES0_EDORR);
+}
+
+static void ftgmac100_rxdes_set_dma_addr(struct ftgmac100_rxdes *rxdes,
+					 dma_addr_t addr)
+{
+	rxdes->rxdes3 = cpu_to_le32(addr);
+}
+
+static dma_addr_t ftgmac100_rxdes_get_dma_addr(struct ftgmac100_rxdes *rxdes)
+{
+	return le32_to_cpu(rxdes->rxdes3);
+}
+
+static bool ftgmac100_rxdes_is_tcp(struct ftgmac100_rxdes *rxdes)
+{
+	return (rxdes->rxdes1 & cpu_to_le32(FTGMAC100_RXDES1_PROT_MASK)) ==
+	       cpu_to_le32(FTGMAC100_RXDES1_PROT_TCPIP);
+}
+
+static bool ftgmac100_rxdes_is_udp(struct ftgmac100_rxdes *rxdes)
+{
+	return (rxdes->rxdes1 & cpu_to_le32(FTGMAC100_RXDES1_PROT_MASK)) ==
+	       cpu_to_le32(FTGMAC100_RXDES1_PROT_UDPIP);
+}
+
+static bool ftgmac100_rxdes_tcpcs_err(struct ftgmac100_rxdes *rxdes)
+{
+	return rxdes->rxdes1 & cpu_to_le32(FTGMAC100_RXDES1_TCP_CHKSUM_ERR);
+}
+
+static bool ftgmac100_rxdes_udpcs_err(struct ftgmac100_rxdes *rxdes)
+{
+	return rxdes->rxdes1 & cpu_to_le32(FTGMAC100_RXDES1_UDP_CHKSUM_ERR);
+}
+
+static bool ftgmac100_rxdes_ipcs_err(struct ftgmac100_rxdes *rxdes)
+{
+	return rxdes->rxdes1 & cpu_to_le32(FTGMAC100_RXDES1_IP_CHKSUM_ERR);
+}
+
+/*
+ * rxdes2 is not used by hardware. We use it to keep track of page.
+ * Since hardware does not touch it, we can skip cpu_to_le32()/le32_to_cpu().
+ */
+static void ftgmac100_rxdes_set_page(struct ftgmac100_rxdes *rxdes, struct page *page)
+{
+	rxdes->rxdes2 = (unsigned int)page;
+}
+
+static struct page *ftgmac100_rxdes_get_page(struct ftgmac100_rxdes *rxdes)
+{
+	return (struct page *)rxdes->rxdes2;
+}
+
+/******************************************************************************
+ * internal functions (receive)
+ *****************************************************************************/
+static int ftgmac100_next_rx_pointer(int pointer)
+{
+	return (pointer + 1) & (RX_QUEUE_ENTRIES - 1);
+}
+
+static void ftgmac100_rx_pointer_advance(struct ftgmac100 *priv)
+{
+	priv->rx_pointer = ftgmac100_next_rx_pointer(priv->rx_pointer);
+}
+
+static struct ftgmac100_rxdes *ftgmac100_current_rxdes(struct ftgmac100 *priv)
+{
+	return &priv->descs->rxdes[priv->rx_pointer];
+}
+
+static struct ftgmac100_rxdes *
+ftgmac100_rx_locate_first_segment(struct ftgmac100 *priv)
+{
+	struct ftgmac100_rxdes *rxdes = ftgmac100_current_rxdes(priv);
+
+	while (ftgmac100_rxdes_packet_ready(rxdes)) {
+		if (ftgmac100_rxdes_first_segment(rxdes))
+			return rxdes;
+
+		ftgmac100_rxdes_set_dma_own(rxdes);
+		ftgmac100_rx_pointer_advance(priv);
+		rxdes = ftgmac100_current_rxdes(priv);
+	}
+
+	return NULL;
+}
+
+static bool ftgmac100_rx_packet_error(struct ftgmac100 *priv,
+				      struct ftgmac100_rxdes *rxdes)
+{
+	struct net_device *netdev = priv->netdev;
+	bool error = false;
+
+	if (unlikely(ftgmac100_rxdes_rx_error(rxdes))) {
+		if (net_ratelimit())
+			netdev_info(netdev, "rx err\n");
+
+		netdev->stats.rx_errors++;
+		error = true;
+	}
+
+	if (unlikely(ftgmac100_rxdes_crc_error(rxdes))) {
+		if (net_ratelimit())
+			netdev_info(netdev, "rx crc err\n");
+
+		netdev->stats.rx_crc_errors++;
+		error = true;
+	} else if (unlikely(ftgmac100_rxdes_ipcs_err(rxdes))) {
+		if (net_ratelimit())
+			netdev_info(netdev, "rx IP checksum err\n");
+
+		error = true;
+	}
+
+	if (unlikely(ftgmac100_rxdes_frame_too_long(rxdes))) {
+		if (net_ratelimit())
+			netdev_info(netdev, "rx frame too long\n");
+
+		netdev->stats.rx_length_errors++;
+		error = true;
+	} else if (unlikely(ftgmac100_rxdes_runt(rxdes))) {
+		if (net_ratelimit())
+			netdev_info(netdev, "rx runt\n");
+
+		netdev->stats.rx_length_errors++;
+		error = true;
+	} else if (unlikely(ftgmac100_rxdes_odd_nibble(rxdes))) {
+		if (net_ratelimit())
+			netdev_info(netdev, "rx odd nibble\n");
+
+		netdev->stats.rx_length_errors++;
+		error = true;
+	}
+
+	return error;
+}
+
+static void ftgmac100_rx_drop_packet(struct ftgmac100 *priv)
+{
+	struct net_device *netdev = priv->netdev;
+	struct ftgmac100_rxdes *rxdes = ftgmac100_current_rxdes(priv);
+	bool done = false;
+
+	if (net_ratelimit())
+		netdev_dbg(netdev, "drop packet %p\n", rxdes);
+
+	do {
+		if (ftgmac100_rxdes_last_segment(rxdes))
+			done = true;
+
+		ftgmac100_rxdes_set_dma_own(rxdes);
+		ftgmac100_rx_pointer_advance(priv);
+		rxdes = ftgmac100_current_rxdes(priv);
+	} while (!done && ftgmac100_rxdes_packet_ready(rxdes));
+
+	netdev->stats.rx_dropped++;
+}
+
+static bool ftgmac100_rx_packet(struct ftgmac100 *priv, int *processed)
+{
+	struct net_device *netdev = priv->netdev;
+	struct ftgmac100_rxdes *rxdes;
+	struct sk_buff *skb;
+	bool done = false;
+
+	rxdes = ftgmac100_rx_locate_first_segment(priv);
+	if (!rxdes)
+		return false;
+
+	if (unlikely(ftgmac100_rx_packet_error(priv, rxdes))) {
+		ftgmac100_rx_drop_packet(priv);
+		return true;
+	}
+
+	/* start processing */
+	skb = netdev_alloc_skb_ip_align(netdev, 128);
+	if (unlikely(!skb)) {
+		if (net_ratelimit())
+			netdev_err(netdev, "rx skb alloc failed\n");
+
+		ftgmac100_rx_drop_packet(priv);
+		return true;
+	}
+
+	if (unlikely(ftgmac100_rxdes_multicast(rxdes)))
+		netdev->stats.multicast++;
+
+	/*
+	 * It seems that HW does checksum incorrectly with fragmented packets,
+	 * so we are conservative here - if HW checksum error, let software do
+	 * the checksum again.
+	 */
+	if ((ftgmac100_rxdes_is_tcp(rxdes) && !ftgmac100_rxdes_tcpcs_err(rxdes)) ||
+	    (ftgmac100_rxdes_is_udp(rxdes) && !ftgmac100_rxdes_udpcs_err(rxdes)))
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+	do {
+		dma_addr_t map = ftgmac100_rxdes_get_dma_addr(rxdes);
+		struct page *page = ftgmac100_rxdes_get_page(rxdes);
+		unsigned int size;
+
+		dma_unmap_page(priv->dev, map, RX_BUF_SIZE, DMA_FROM_DEVICE);
+
+		size = ftgmac100_rxdes_data_length(rxdes);
+		skb_fill_page_desc(skb, skb_shinfo(skb)->nr_frags, page, 0, size);
+
+		skb->len += size;
+		skb->data_len += size;
+		skb->truesize += PAGE_SIZE;
+
+		if (ftgmac100_rxdes_last_segment(rxdes))
+			done = true;
+
+		ftgmac100_alloc_rx_page(priv, rxdes, GFP_ATOMIC);
+
+		ftgmac100_rx_pointer_advance(priv);
+		rxdes = ftgmac100_current_rxdes(priv);
+	} while (!done);
+
+	if (skb->len <= 64)
+		skb->truesize -= PAGE_SIZE;
+	__pskb_pull_tail(skb, min(skb->len, 64U));
+	skb->protocol = eth_type_trans(skb, netdev);
+
+	netdev->stats.rx_packets++;
+	netdev->stats.rx_bytes += skb->len;
+
+	/* push packet to protocol stack */
+	napi_gro_receive(&priv->napi, skb);
+
+	(*processed)++;
+	return true;
+}
+
+/******************************************************************************
+ * internal functions (transmit descriptor)
+ *****************************************************************************/
+static void ftgmac100_txdes_reset(struct ftgmac100_txdes *txdes)
+{
+	/* clear all except end of ring bit */
+	txdes->txdes0 &= cpu_to_le32(FTGMAC100_TXDES0_EDOTR);
+	txdes->txdes1 = 0;
+	txdes->txdes2 = 0;
+	txdes->txdes3 = 0;
+}
+
+static bool ftgmac100_txdes_owned_by_dma(struct ftgmac100_txdes *txdes)
+{
+	return txdes->txdes0 & cpu_to_le32(FTGMAC100_TXDES0_TXDMA_OWN);
+}
+
+static void ftgmac100_txdes_set_dma_own(struct ftgmac100_txdes *txdes)
+{
+	/*
+	 * Make sure dma own bit will not be set before any other
+	 * descriptor fields.
+	 */
+	wmb();
+	txdes->txdes0 |= cpu_to_le32(FTGMAC100_TXDES0_TXDMA_OWN);
+}
+
+static void ftgmac100_txdes_set_end_of_ring(struct ftgmac100_txdes *txdes)
+{
+	txdes->txdes0 |= cpu_to_le32(FTGMAC100_TXDES0_EDOTR);
+}
+
+static void ftgmac100_txdes_set_first_segment(struct ftgmac100_txdes *txdes)
+{
+	txdes->txdes0 |= cpu_to_le32(FTGMAC100_TXDES0_FTS);
+}
+
+static void ftgmac100_txdes_set_last_segment(struct ftgmac100_txdes *txdes)
+{
+	txdes->txdes0 |= cpu_to_le32(FTGMAC100_TXDES0_LTS);
+}
+
+static void ftgmac100_txdes_set_buffer_size(struct ftgmac100_txdes *txdes,
+					    unsigned int len)
+{
+	txdes->txdes0 |= cpu_to_le32(FTGMAC100_TXDES0_TXBUF_SIZE(len));
+}
+
+static void ftgmac100_txdes_set_txint(struct ftgmac100_txdes *txdes)
+{
+	txdes->txdes1 |= cpu_to_le32(FTGMAC100_TXDES1_TXIC);
+}
+
+static void ftgmac100_txdes_set_tcpcs(struct ftgmac100_txdes *txdes)
+{
+	txdes->txdes1 |= cpu_to_le32(FTGMAC100_TXDES1_TCP_CHKSUM);
+}
+
+static void ftgmac100_txdes_set_udpcs(struct ftgmac100_txdes *txdes)
+{
+	txdes->txdes1 |= cpu_to_le32(FTGMAC100_TXDES1_UDP_CHKSUM);
+}
+
+static void ftgmac100_txdes_set_ipcs(struct ftgmac100_txdes *txdes)
+{
+	txdes->txdes1 |= cpu_to_le32(FTGMAC100_TXDES1_IP_CHKSUM);
+}
+
+static void ftgmac100_txdes_set_dma_addr(struct ftgmac100_txdes *txdes,
+					 dma_addr_t addr)
+{
+	txdes->txdes3 = cpu_to_le32(addr);
+}
+
+static dma_addr_t ftgmac100_txdes_get_dma_addr(struct ftgmac100_txdes *txdes)
+{
+	return le32_to_cpu(txdes->txdes3);
+}
+
+/*
+ * txdes2 is not used by hardware. We use it to keep track of socket buffer.
+ * Since hardware does not touch it, we can skip cpu_to_le32()/le32_to_cpu().
+ */
+static void ftgmac100_txdes_set_skb(struct ftgmac100_txdes *txdes,
+				    struct sk_buff *skb)
+{
+	txdes->txdes2 = (unsigned int)skb;
+}
+
+static struct sk_buff *ftgmac100_txdes_get_skb(struct ftgmac100_txdes *txdes)
+{
+	return (struct sk_buff *)txdes->txdes2;
+}
+
+/******************************************************************************
+ * internal functions (transmit)
+ *****************************************************************************/
+static int ftgmac100_next_tx_pointer(int pointer)
+{
+	return (pointer + 1) & (TX_QUEUE_ENTRIES - 1);
+}
+
+static void ftgmac100_tx_pointer_advance(struct ftgmac100 *priv)
+{
+	priv->tx_pointer = ftgmac100_next_tx_pointer(priv->tx_pointer);
+}
+
+static void ftgmac100_tx_clean_pointer_advance(struct ftgmac100 *priv)
+{
+	priv->tx_clean_pointer = ftgmac100_next_tx_pointer(priv->tx_clean_pointer);
+}
+
+static struct ftgmac100_txdes *ftgmac100_current_txdes(struct ftgmac100 *priv)
+{
+	return &priv->descs->txdes[priv->tx_pointer];
+}
+
+static struct ftgmac100_txdes *
+ftgmac100_current_clean_txdes(struct ftgmac100 *priv)
+{
+	return &priv->descs->txdes[priv->tx_clean_pointer];
+}
+
+static bool ftgmac100_tx_complete_packet(struct ftgmac100 *priv)
+{
+	struct net_device *netdev = priv->netdev;
+	struct ftgmac100_txdes *txdes;
+	struct sk_buff *skb;
+	dma_addr_t map;
+
+	if (priv->tx_pending == 0)
+		return false;
+
+	txdes = ftgmac100_current_clean_txdes(priv);
+
+	if (ftgmac100_txdes_owned_by_dma(txdes))
+		return false;
+
+	skb = ftgmac100_txdes_get_skb(txdes);
+	map = ftgmac100_txdes_get_dma_addr(txdes);
+
+	netdev->stats.tx_packets++;
+	netdev->stats.tx_bytes += skb->len;
+
+	dma_unmap_single(priv->dev, map, skb_headlen(skb), DMA_TO_DEVICE);
+
+	dev_kfree_skb(skb);
+
+	ftgmac100_txdes_reset(txdes);
+
+	ftgmac100_tx_clean_pointer_advance(priv);
+
+	spin_lock(&priv->tx_lock);
+	priv->tx_pending--;
+	spin_unlock(&priv->tx_lock);
+	netif_wake_queue(netdev);
+
+	return true;
+}
+
+static void ftgmac100_tx_complete(struct ftgmac100 *priv)
+{
+	while (ftgmac100_tx_complete_packet(priv))
+		;
+}
+
+static int ftgmac100_xmit(struct ftgmac100 *priv, struct sk_buff *skb,
+			  dma_addr_t map)
+{
+	struct net_device *netdev = priv->netdev;
+	struct ftgmac100_txdes *txdes;
+	unsigned int len = (skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;
+
+	txdes = ftgmac100_current_txdes(priv);
+	ftgmac100_tx_pointer_advance(priv);
+
+	/* setup TX descriptor */
+	ftgmac100_txdes_set_skb(txdes, skb);
+	ftgmac100_txdes_set_dma_addr(txdes, map);
+	ftgmac100_txdes_set_buffer_size(txdes, len);
+
+	ftgmac100_txdes_set_first_segment(txdes);
+	ftgmac100_txdes_set_last_segment(txdes);
+	ftgmac100_txdes_set_txint(txdes);
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		__be16 protocol = skb->protocol;
+
+		if (protocol == cpu_to_be16(ETH_P_IP)) {
+			u8 ip_proto = ip_hdr(skb)->protocol;
+
+			ftgmac100_txdes_set_ipcs(txdes);
+			if (ip_proto == IPPROTO_TCP)
+				ftgmac100_txdes_set_tcpcs(txdes);
+			else if (ip_proto == IPPROTO_UDP)
+				ftgmac100_txdes_set_udpcs(txdes);
+		}
+	}
+
+	spin_lock(&priv->tx_lock);
+	priv->tx_pending++;
+	if (priv->tx_pending == TX_QUEUE_ENTRIES)
+		netif_stop_queue(netdev);
+
+	/* start transmit */
+	ftgmac100_txdes_set_dma_own(txdes);
+	spin_unlock(&priv->tx_lock);
+
+	ftgmac100_txdma_normal_prio_start_polling(priv);
+
+	return NETDEV_TX_OK;
+}
+
+/******************************************************************************
+ * internal functions (buffer)
+ *****************************************************************************/
+static int ftgmac100_alloc_rx_page(struct ftgmac100 *priv,
+				   struct ftgmac100_rxdes *rxdes, gfp_t gfp)
+{
+	struct net_device *netdev = priv->netdev;
+	struct page *page;
+	dma_addr_t map;
+
+	page = alloc_page(gfp);
+	if (!page) {
+		if (net_ratelimit())
+			netdev_err(netdev, "failed to allocate rx page\n");
+		return -ENOMEM;
+	}
+
+	map = dma_map_page(priv->dev, page, 0, RX_BUF_SIZE, DMA_FROM_DEVICE);
+	if (unlikely(dma_mapping_error(priv->dev, map))) {
+		if (net_ratelimit())
+			netdev_err(netdev, "failed to map rx page\n");
+		__free_page(page);
+		return -ENOMEM;
+	}
+
+	ftgmac100_rxdes_set_page(rxdes, page);
+	ftgmac100_rxdes_set_dma_addr(rxdes, map);
+	ftgmac100_rxdes_set_dma_own(rxdes);
+	return 0;
+}
+
+static void ftgmac100_free_buffers(struct ftgmac100 *priv)
+{
+	int i;
+
+	for (i = 0; i < RX_QUEUE_ENTRIES; i++) {
+		struct ftgmac100_rxdes *rxdes = &priv->descs->rxdes[i];
+		struct page *page = ftgmac100_rxdes_get_page(rxdes);
+		dma_addr_t map = ftgmac100_rxdes_get_dma_addr(rxdes);
+
+		if (!page)
+			continue;
+
+		dma_unmap_page(priv->dev, map, RX_BUF_SIZE, DMA_FROM_DEVICE);
+		__free_page(page);
+	}
+
+	for (i = 0; i < TX_QUEUE_ENTRIES; i++) {
+		struct ftgmac100_txdes *txdes = &priv->descs->txdes[i];
+		struct sk_buff *skb = ftgmac100_txdes_get_skb(txdes);
+		dma_addr_t map = ftgmac100_txdes_get_dma_addr(txdes);
+
+		if (!skb)
+			continue;
+
+		dma_unmap_single(priv->dev, map, skb_headlen(skb), DMA_TO_DEVICE);
+		dev_kfree_skb(skb);
+	}
+
+	dma_free_coherent(priv->dev, sizeof(struct ftgmac100_descs),
+			  priv->descs, priv->descs_dma_addr);
+}
+
+static int ftgmac100_alloc_buffers(struct ftgmac100 *priv)
+{
+	int i;
+
+	priv->descs = dma_alloc_coherent(priv->dev,
+					 sizeof(struct ftgmac100_descs),
+					 &priv->descs_dma_addr, GFP_KERNEL);
+	if (!priv->descs)
+		return -ENOMEM;
+
+	memset(priv->descs, 0, sizeof(struct ftgmac100_descs));
+
+	/* initialize RX ring */
+	ftgmac100_rxdes_set_end_of_ring(&priv->descs->rxdes[RX_QUEUE_ENTRIES - 1]);
+
+	for (i = 0; i < RX_QUEUE_ENTRIES; i++) {
+		struct ftgmac100_rxdes *rxdes = &priv->descs->rxdes[i];
+
+		if (ftgmac100_alloc_rx_page(priv, rxdes, GFP_KERNEL))
+			goto err;
+	}
+
+	/* initialize TX ring */
+	ftgmac100_txdes_set_end_of_ring(&priv->descs->txdes[TX_QUEUE_ENTRIES - 1]);
+	return 0;
+
+err:
+	ftgmac100_free_buffers(priv);
+	return -ENOMEM;
+}
+
+/******************************************************************************
+ * internal functions (mdio)
+ *****************************************************************************/
+static void ftgmac100_adjust_link(struct net_device *netdev)
+{
+	struct ftgmac100 *priv = netdev_priv(netdev);
+	struct phy_device *phydev = priv->phydev;
+	int ier;
+
+	if (phydev->speed == priv->old_speed)
+		return;
+
+	priv->old_speed = phydev->speed;
+
+	ier = ioread32(priv->base + FTGMAC100_OFFSET_IER);
+
+	/* disable all interrupts */
+	iowrite32(0, priv->base + FTGMAC100_OFFSET_IER);
+
+	netif_stop_queue(netdev);
+	ftgmac100_stop_hw(priv);
+
+	netif_start_queue(netdev);
+	ftgmac100_init_hw(priv);
+	ftgmac100_start_hw(priv, phydev->speed);
+
+	/* re-enable interrupts */
+	iowrite32(ier, priv->base + FTGMAC100_OFFSET_IER);
+}
+
+static int ftgmac100_mii_probe(struct ftgmac100 *priv)
+{
+	struct net_device *netdev = priv->netdev;
+	struct phy_device *phydev = NULL;
+	int i;
+
+	/* search for connect PHY device */
+	for (i = 0; i < PHY_MAX_ADDR; i++) {
+		struct phy_device *tmp = priv->mii_bus->phy_map[i];
+
+		if (tmp) {
+			phydev = tmp;
+			break;
+		}
+	}
+
+	/* now we are supposed to have a proper phydev, to attach to... */
+	if (!phydev) {
+		netdev_info(netdev, "%s: no PHY found\n", netdev->name);
+		return -ENODEV;
+	}
+
+	phydev = phy_connect(netdev, dev_name(&phydev->dev),
+			     &ftgmac100_adjust_link, 0,
+			     PHY_INTERFACE_MODE_GMII);
+
+	if (IS_ERR(phydev)) {
+		netdev_err(netdev, "%s: Could not attach to PHY\n", netdev->name);
+		return PTR_ERR(phydev);
+	}
+
+	priv->phydev = phydev;
+	return 0;
+}
+
+/******************************************************************************
+ * struct mii_bus functions
+ *****************************************************************************/
+static int ftgmac100_mdiobus_read(struct mii_bus *bus, int phy_addr, int regnum)
+{
+	struct net_device *netdev = bus->priv;
+	struct ftgmac100 *priv = netdev_priv(netdev);
+	unsigned int phycr;
+	int i;
+
+	phycr = ioread32(priv->base + FTGMAC100_OFFSET_PHYCR);
+
+	/* preserve MDC cycle threshold */
+	phycr &= FTGMAC100_PHYCR_MDC_CYCTHR_MASK;
+
+	phycr |= FTGMAC100_PHYCR_PHYAD(phy_addr) |
+		 FTGMAC100_PHYCR_REGAD(regnum) |
+		 FTGMAC100_PHYCR_MIIRD;
+
+	iowrite32(phycr, priv->base + FTGMAC100_OFFSET_PHYCR);
+
+	for (i = 0; i < 10; i++) {
+		phycr = ioread32(priv->base + FTGMAC100_OFFSET_PHYCR);
+
+		if ((phycr & FTGMAC100_PHYCR_MIIRD) == 0) {
+			int data;
+
+			data = ioread32(priv->base + FTGMAC100_OFFSET_PHYDATA);
+			return FTGMAC100_PHYDATA_MIIRDATA(data);
+		}
+
+		udelay(100);
+	}
+
+	netdev_err(netdev, "mdio read timed out\n");
+	return -EIO;
+}
+
+static int ftgmac100_mdiobus_write(struct mii_bus *bus, int phy_addr,
+				   int regnum, u16 value)
+{
+	struct net_device *netdev = bus->priv;
+	struct ftgmac100 *priv = netdev_priv(netdev);
+	unsigned int phycr;
+	int data;
+	int i;
+
+	phycr = ioread32(priv->base + FTGMAC100_OFFSET_PHYCR);
+
+	/* preserve MDC cycle threshold */
+	phycr &= FTGMAC100_PHYCR_MDC_CYCTHR_MASK;
+
+	phycr |= FTGMAC100_PHYCR_PHYAD(phy_addr) |
+		 FTGMAC100_PHYCR_REGAD(regnum) |
+		 FTGMAC100_PHYCR_MIIWR;
+
+	data = FTGMAC100_PHYDATA_MIIWDATA(value);
+
+	iowrite32(data, priv->base + FTGMAC100_OFFSET_PHYDATA);
+	iowrite32(phycr, priv->base + FTGMAC100_OFFSET_PHYCR);
+
+	for (i = 0; i < 10; i++) {
+		phycr = ioread32(priv->base + FTGMAC100_OFFSET_PHYCR);
+
+		if ((phycr & FTGMAC100_PHYCR_MIIWR) == 0)
+			return 0;
+
+		udelay(100);
+	}
+
+	netdev_err(netdev, "mdio write timed out\n");
+	return -EIO;
+}
+
+static int ftgmac100_mdiobus_reset(struct mii_bus *bus)
+{
+	return 0;
+}
+
+/******************************************************************************
+ * struct ethtool_ops functions
+ *****************************************************************************/
+static void ftgmac100_get_drvinfo(struct net_device *netdev,
+				  struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, DRV_NAME);
+	strcpy(info->version, DRV_VERSION);
+	strcpy(info->bus_info, dev_name(&netdev->dev));
+}
+
+static int ftgmac100_get_settings(struct net_device *netdev,
+				  struct ethtool_cmd *cmd)
+{
+	struct ftgmac100 *priv = netdev_priv(netdev);
+
+	return phy_ethtool_gset(priv->phydev, cmd);
+}
+
+static int ftgmac100_set_settings(struct net_device *netdev,
+				  struct ethtool_cmd *cmd)
+{
+	struct ftgmac100 *priv = netdev_priv(netdev);
+
+	return phy_ethtool_sset(priv->phydev, cmd);
+}
+
+static const struct ethtool_ops ftgmac100_ethtool_ops = {
+	.set_settings		= ftgmac100_set_settings,
+	.get_settings		= ftgmac100_get_settings,
+	.get_drvinfo		= ftgmac100_get_drvinfo,
+	.get_link		= ethtool_op_get_link,
+};
+
+/******************************************************************************
+ * interrupt handler
+ *****************************************************************************/
+static irqreturn_t ftgmac100_interrupt(int irq, void *dev_id)
+{
+	struct net_device *netdev = dev_id;
+	struct ftgmac100 *priv = netdev_priv(netdev);
+
+	if (likely(netif_running(netdev))) {
+		/* Disable interrupts for polling */
+		iowrite32(0, priv->base + FTGMAC100_OFFSET_IER);
+		napi_schedule(&priv->napi);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/******************************************************************************
+ * struct napi_struct functions
+ *****************************************************************************/
+static int ftgmac100_poll(struct napi_struct *napi, int budget)
+{
+	struct ftgmac100 *priv = container_of(napi, struct ftgmac100, napi);
+	struct net_device *netdev = priv->netdev;
+	unsigned int status;
+	bool completed = true;
+	int rx = 0;
+
+	status = ioread32(priv->base + FTGMAC100_OFFSET_ISR);
+	iowrite32(status, priv->base + FTGMAC100_OFFSET_ISR);
+	status &= ioread32(priv->base + FTGMAC100_OFFSET_IER);
+
+
+	if (status & (FTGMAC100_INT_RPKT_BUF | FTGMAC100_INT_NO_RXBUF)) {
+		/*
+		 * FTGMAC100_INT_RPKT_BUF:
+		 *	RX DMA has received packets into RX buffer successfully
+		 *
+		 * FTGMAC100_INT_NO_RXBUF:
+		 *	RX buffer unavailable
+		 */
+		bool retry;
+
+		do {
+			retry = ftgmac100_rx_packet(priv, &rx);
+		} while (retry && rx < budget);
+
+		if (retry && rx == budget)
+			completed = false;
+	}
+
+	if (status & (FTGMAC100_INT_XPKT_ETH | FTGMAC100_INT_XPKT_LOST)) {
+		/*
+		 * FTGMAC100_INT_XPKT_ETH:
+		 *	packet transmitted to ethernet successfully
+		 *
+		 * FTGMAC100_INT_XPKT_LOST:
+		 *	packet transmitted to ethernet lost due to late
+		 *	collision or excessive collision
+		 */
+		ftgmac100_tx_complete(priv);
+	}
+
+	if (status & (FTGMAC100_INT_NO_RXBUF | FTGMAC100_INT_RPKT_LOST |
+		      FTGMAC100_INT_AHB_ERR | FTGMAC100_INT_PHYSTS_CHG)) {
+		if (net_ratelimit())
+			netdev_info(netdev, "[ISR] = 0x%x: %s%s%s%s\n", status,
+				    status & FTGMAC100_INT_NO_RXBUF ? "NO_RXBUF " : "",
+				    status & FTGMAC100_INT_RPKT_LOST ? "RPKT_LOST " : "",
+				    status & FTGMAC100_INT_AHB_ERR ? "AHB_ERR " : "",
+				    status & FTGMAC100_INT_PHYSTS_CHG ? "PHYSTS_CHG" : "");
+
+		if (status & FTGMAC100_INT_NO_RXBUF) {
+			/* RX buffer unavailable */
+			netdev->stats.rx_over_errors++;
+		}
+
+		if (status & FTGMAC100_INT_RPKT_LOST) {
+			/* received packet lost due to RX FIFO full */
+			netdev->stats.rx_fifo_errors++;
+		}
+	//	if (status & FTGMAC100_INT_PHYSTS_CHG) {
+	//		printk("phy change .. -----------------------------------------\n");
+	//		ftgmac100_adjust_link(netdev);
+	//	}
+	}
+
+	if (completed) {
+		napi_complete(napi);
+
+		/* enable all interrupts */
+		iowrite32(INT_MASK_ALL_ENABLED, priv->base + FTGMAC100_OFFSET_IER);
+	}
+
+	return rx;
+}
+
+/******************************************************************************
+ * struct net_device_ops functions
+ *****************************************************************************/
+static int ftgmac100_open(struct net_device *netdev)
+{
+	struct ftgmac100 *priv = netdev_priv(netdev);
+	int err;
+
+	err = ftgmac100_alloc_buffers(priv);
+	if (err) {
+		netdev_err(netdev, "failed to allocate buffers\n");
+		goto err_alloc;
+	}
+
+	err = request_irq(priv->irq, ftgmac100_interrupt, 0, netdev->name, netdev);
+	if (err) {
+		netdev_err(netdev, "failed to request irq %d\n", priv->irq);
+		goto err_irq;
+	}
+
+	priv->rx_pointer = 0;
+	priv->tx_clean_pointer = 0;
+	priv->tx_pointer = 0;
+	priv->tx_pending = 0;
+
+	err = ftgmac100_reset_hw(priv);
+	if (err)
+		goto err_hw;
+
+	ftgmac100_init_hw(priv);
+	ftgmac100_start_hw(priv, 10);
+
+	phy_start(priv->phydev);
+
+	napi_enable(&priv->napi);
+	netif_start_queue(netdev);
+
+	/* enable all interrupts */
+	iowrite32(INT_MASK_ALL_ENABLED, priv->base + FTGMAC100_OFFSET_IER);
+	return 0;
+
+err_hw:
+	free_irq(priv->irq, netdev);
+err_irq:
+	ftgmac100_free_buffers(priv);
+err_alloc:
+	return err;
+}
+
+static int ftgmac100_stop(struct net_device *netdev)
+{
+	struct ftgmac100 *priv = netdev_priv(netdev);
+
+	/* disable all interrupts */
+	iowrite32(0, priv->base + FTGMAC100_OFFSET_IER);
+
+	netif_stop_queue(netdev);
+	napi_disable(&priv->napi);
+	phy_stop(priv->phydev);
+
+	ftgmac100_stop_hw(priv);
+	free_irq(priv->irq, netdev);
+	ftgmac100_free_buffers(priv);
+
+	return 0;
+}
+
+static int ftgmac100_hard_start_xmit(struct sk_buff *skb,
+				     struct net_device *netdev)
+{
+	struct ftgmac100 *priv = netdev_priv(netdev);
+	dma_addr_t map;
+
+	if (unlikely(skb->len > MAX_PKT_SIZE)) {
+		if (net_ratelimit())
+			netdev_dbg(netdev, "tx packet too big\n");
+
+		netdev->stats.tx_dropped++;
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	map = dma_map_single(priv->dev, skb->data, skb_headlen(skb), DMA_TO_DEVICE);
+	if (unlikely(dma_mapping_error(priv->dev, map))) {
+		/* drop packet */
+		if (net_ratelimit())
+			netdev_err(netdev, "map socket buffer failed\n");
+
+		netdev->stats.tx_dropped++;
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	return ftgmac100_xmit(priv, skb, map);
+}
+
+/* optional */
+static int ftgmac100_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+	struct ftgmac100 *priv = netdev_priv(netdev);
+
+	return phy_mii_ioctl(priv->phydev, ifr, cmd);
+}
+
+static const struct net_device_ops ftgmac100_netdev_ops = {
+	.ndo_open		= ftgmac100_open,
+	.ndo_stop		= ftgmac100_stop,
+	.ndo_start_xmit		= ftgmac100_hard_start_xmit,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_do_ioctl		= ftgmac100_do_ioctl,
+};
+
+/******************************************************************************
+ * struct platform_driver functions
+ *****************************************************************************/
+static int ftgmac100_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int irq;
+	struct net_device *netdev;
+	struct ftgmac100 *priv;
+	int err;
+	int i;
+	struct ftgmac100_eth_data *ast_eth_data = pdev->dev.platform_data;;
+
+	if (!pdev)
+		return -ENODEV;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENXIO;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	/* setup net_device */
+	netdev = alloc_etherdev(sizeof(*priv));
+	if (!netdev) {
+		err = -ENOMEM;
+		goto err_alloc_etherdev;
+	}
+
+	SET_NETDEV_DEV(netdev, &pdev->dev);
+
+	netdev->ethtool_ops = &ftgmac100_ethtool_ops;
+	netdev->netdev_ops = &ftgmac100_netdev_ops;
+	netdev->features = NETIF_F_IP_CSUM | NETIF_F_GRO;
+
+	platform_set_drvdata(pdev, netdev);
+
+	/* setup private data */
+	priv = netdev_priv(netdev);
+	priv->netdev = netdev;
+	priv->dev = &pdev->dev;
+
+	spin_lock_init(&priv->tx_lock);
+
+	/* initialize NAPI */
+	netif_napi_add(netdev, &priv->napi, ftgmac100_poll, 64);
+
+	/* map io memory */
+	priv->res = request_mem_region(res->start, resource_size(res),
+				       dev_name(&pdev->dev));
+	if (!priv->res) {
+		dev_err(&pdev->dev, "Could not reserve memory region\n");
+		err = -ENOMEM;
+		goto err_req_mem;
+	}
+
+	priv->base = ioremap(res->start, resource_size(res));
+	if (!priv->base) {
+		dev_err(&pdev->dev, "Failed to ioremap ethernet registers\n");
+		err = -EIO;
+		goto err_ioremap;
+	}
+
+	priv->irq = irq;
+
+	/* initialize mdio bus */
+	priv->mii_bus = mdiobus_alloc();
+	if (!priv->mii_bus) {
+		err = -EIO;
+		goto err_alloc_mdiobus;
+	}
+
+	priv->mii_bus->name = "ftgmac100_mdio";
+	snprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, "ftgmac100_mii_%d",pdev->id);
+
+	priv->mii_bus->priv = netdev;
+	priv->mii_bus->read = ftgmac100_mdiobus_read;
+	priv->mii_bus->write = ftgmac100_mdiobus_write;
+	priv->mii_bus->reset = ftgmac100_mdiobus_reset;
+	priv->mii_bus->irq = priv->phy_irq;
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		priv->mii_bus->irq[i] = PHY_POLL;
+
+	err = mdiobus_register(priv->mii_bus);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot register MDIO bus!\n");
+		goto err_register_mdiobus;
+	}
+
+	err = ftgmac100_mii_probe(priv);
+	if (err) {
+		dev_err(&pdev->dev, "MII Probe failed!\n");
+		goto err_mii_probe;
+	}
+
+	/* register network device */
+	err = register_netdev(netdev);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to register netdev\n");
+		goto err_register_netdev;
+	}
+
+//	netdev_info(netdev, "irq %d, mapped at %p\n", priv->irq, priv->base);
+
+	memcpy(netdev->dev_addr,ast_eth_data->dev_addr,ETH_ALEN);
+	if (!is_valid_ether_addr(netdev->dev_addr)) {
+		eth_hw_addr_random(netdev);
+		netdev_info(netdev, "generated random MAC address %pM\n",
+			    netdev->dev_addr);
+	}
+
+	printk("%s : MAC %pM irq %d, mapped at %p\n", netdev->name,netdev->dev_addr,priv->irq, priv->base);
+	return 0;
+
+err_register_netdev:
+	phy_disconnect(priv->phydev);
+err_mii_probe:
+	mdiobus_unregister(priv->mii_bus);
+err_register_mdiobus:
+	mdiobus_free(priv->mii_bus);
+err_alloc_mdiobus:
+	iounmap(priv->base);
+err_ioremap:
+	release_resource(priv->res);
+err_req_mem:
+	netif_napi_del(&priv->napi);
+	platform_set_drvdata(pdev, NULL);
+	free_netdev(netdev);
+err_alloc_etherdev:
+	return err;
+}
+
+static int __exit ftgmac100_remove(struct platform_device *pdev)
+{
+	struct net_device *netdev;
+	struct ftgmac100 *priv;
+
+	netdev = platform_get_drvdata(pdev);
+	priv = netdev_priv(netdev);
+
+	unregister_netdev(netdev);
+
+	phy_disconnect(priv->phydev);
+	mdiobus_unregister(priv->mii_bus);
+	mdiobus_free(priv->mii_bus);
+
+	iounmap(priv->base);
+	release_resource(priv->res);
+
+	netif_napi_del(&priv->napi);
+	platform_set_drvdata(pdev, NULL);
+	free_netdev(netdev);
+	return 0;
+}
+
+static struct platform_driver ftgmac100_driver = {
+	.probe		= ftgmac100_probe,
+	.remove		= __exit_p(ftgmac100_remove),
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+/******************************************************************************
+ * initialization / finalization
+ *****************************************************************************/
+extern void __init ast_add_device_gmac(void);
+static int __init ftgmac100_init(void)
+{
+	pr_info("Loading AST GMAC Network Driver version " DRV_VERSION " ...\n");
+	ast_add_device_gmac();
+	return platform_driver_register(&ftgmac100_driver);
+}
+
+static void __exit ftgmac100_exit(void)
+{
+	platform_driver_unregister(&ftgmac100_driver);
+}
+
+module_init(ftgmac100_init);
+module_exit(ftgmac100_exit);
+
+MODULE_AUTHOR("Po-Yu Chuang <ratbert@faraday-tech.com>");
+MODULE_DESCRIPTION("FTGMAC100 driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/aspeed/ftgmac100.h b/drivers/net/ethernet/aspeed/ftgmac100.h
new file mode 100644
index 0000000..a7e45be
--- /dev/null
+++ b/drivers/net/ethernet/aspeed/ftgmac100.h
@@ -0,0 +1,251 @@
+/*
+ * Faraday FTGMAC100 Gigabit Ethernet
+ *
+ * (C) Copyright 2009-2011 Faraday Technology
+ * Po-Yu Chuang <ratbert@faraday-tech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __FTGMAC100_H
+#define __FTGMAC100_H
+
+#define FTGMAC100_OFFSET_ISR		0x00
+#define FTGMAC100_OFFSET_IER		0x04
+#define FTGMAC100_OFFSET_MAC_MADR	0x08
+#define FTGMAC100_OFFSET_MAC_LADR	0x0c
+#define FTGMAC100_OFFSET_MAHT0		0x10
+#define FTGMAC100_OFFSET_MAHT1		0x14
+#define FTGMAC100_OFFSET_NPTXPD		0x18
+#define FTGMAC100_OFFSET_RXPD		0x1c
+#define FTGMAC100_OFFSET_NPTXR_BADR	0x20
+#define FTGMAC100_OFFSET_RXR_BADR	0x24
+#define FTGMAC100_OFFSET_HPTXPD		0x28
+#define FTGMAC100_OFFSET_HPTXR_BADR	0x2c
+#define FTGMAC100_OFFSET_ITC		0x30
+#define FTGMAC100_OFFSET_APTC		0x34
+#define FTGMAC100_OFFSET_DBLAC		0x38
+#define FTGMAC100_OFFSET_DMAFIFOS	0x3c
+#define FTGMAC100_OFFSET_REVR		0x40
+#define FTGMAC100_OFFSET_FEAR		0x44
+#define FTGMAC100_OFFSET_TPAFCR		0x48
+#define FTGMAC100_OFFSET_RBSR		0x4c
+#define FTGMAC100_OFFSET_MACCR		0x50
+#define FTGMAC100_OFFSET_MACSR		0x54
+#define FTGMAC100_OFFSET_TM		0x58
+#define FTGMAC100_OFFSET_PHYCR		0x60
+#define FTGMAC100_OFFSET_PHYDATA	0x64
+#define FTGMAC100_OFFSET_FCR		0x68
+#define FTGMAC100_OFFSET_BPR		0x6c
+#define FTGMAC100_OFFSET_WOLCR		0x70
+#define FTGMAC100_OFFSET_WOLSR		0x74
+#define FTGMAC100_OFFSET_WFCRC		0x78
+#define FTGMAC100_OFFSET_WFBM1		0x80
+#define FTGMAC100_OFFSET_WFBM2		0x84
+#define FTGMAC100_OFFSET_WFBM3		0x88
+#define FTGMAC100_OFFSET_WFBM4		0x8c
+#define FTGMAC100_OFFSET_NPTXR_PTR	0x90
+#define FTGMAC100_OFFSET_HPTXR_PTR	0x94
+#define FTGMAC100_OFFSET_RXR_PTR	0x98
+#define FTGMAC100_OFFSET_TX		0xa0
+#define FTGMAC100_OFFSET_TX_MCOL_SCOL	0xa4
+#define FTGMAC100_OFFSET_TX_ECOL_FAIL	0xa8
+#define FTGMAC100_OFFSET_TX_LCOL_UND	0xac
+#define FTGMAC100_OFFSET_RX		0xb0
+#define FTGMAC100_OFFSET_RX_BC		0xb4
+#define FTGMAC100_OFFSET_RX_MC		0xb8
+#define FTGMAC100_OFFSET_RX_PF_AEP	0xbc
+#define FTGMAC100_OFFSET_RX_RUNT	0xc0
+#define FTGMAC100_OFFSET_RX_CRCER_FTL	0xc4
+#define FTGMAC100_OFFSET_RX_COL_LOST	0xc8
+
+/*
+ * Interrupt status register & interrupt enable register
+ */
+#define FTGMAC100_INT_RPKT_BUF		(1 << 0)
+#define FTGMAC100_INT_RPKT_FIFO		(1 << 1)
+#define FTGMAC100_INT_NO_RXBUF		(1 << 2)
+#define FTGMAC100_INT_RPKT_LOST		(1 << 3)
+#define FTGMAC100_INT_XPKT_ETH		(1 << 4)
+#define FTGMAC100_INT_XPKT_FIFO		(1 << 5)
+#define FTGMAC100_INT_NO_NPTXBUF	(1 << 6)
+#define FTGMAC100_INT_XPKT_LOST		(1 << 7)
+#define FTGMAC100_INT_AHB_ERR		(1 << 8)
+#define FTGMAC100_INT_PHYSTS_CHG	(1 << 9)
+#define FTGMAC100_INT_NO_HPTXBUF	(1 << 10)
+
+/*
+ * Interrupt timer control register
+ */
+#define FTGMAC100_ITC_RXINT_CNT(x)	(((x) & 0xf) << 0)
+#define FTGMAC100_ITC_RXINT_THR(x)	(((x) & 0x7) << 4)
+#define FTGMAC100_ITC_RXINT_TIME_SEL	(1 << 7)
+#define FTGMAC100_ITC_TXINT_CNT(x)	(((x) & 0xf) << 8)
+#define FTGMAC100_ITC_TXINT_THR(x)	(((x) & 0x7) << 12)
+#define FTGMAC100_ITC_TXINT_TIME_SEL	(1 << 15)
+
+/*
+ * Automatic polling timer control register
+ */
+#define FTGMAC100_APTC_RXPOLL_CNT(x)	(((x) & 0xf) << 0)
+#define FTGMAC100_APTC_RXPOLL_TIME_SEL	(1 << 4)
+#define FTGMAC100_APTC_TXPOLL_CNT(x)	(((x) & 0xf) << 8)
+#define FTGMAC100_APTC_TXPOLL_TIME_SEL	(1 << 12)
+
+/*
+ * DMA burst length and arbitration control register
+ */
+#define FTGMAC100_DBLAC_RXFIFO_LTHR(x)	(((x) & 0x7) << 0)
+#define FTGMAC100_DBLAC_RXFIFO_HTHR(x)	(((x) & 0x7) << 3)
+#define FTGMAC100_DBLAC_RX_THR_EN	(1 << 6)
+#define FTGMAC100_DBLAC_RXBURST_SIZE(x)	(((x) & 0x3) << 8)
+#define FTGMAC100_DBLAC_TXBURST_SIZE(x)	(((x) & 0x3) << 10)
+#define FTGMAC100_DBLAC_RXDES_SIZE(x)	(((x) & 0xf) << 12)
+#define FTGMAC100_DBLAC_TXDES_SIZE(x)	(((x) & 0xf) << 16)
+#define FTGMAC100_DBLAC_IFG_CNT(x)	(((x) & 0x7) << 20)
+#define FTGMAC100_DBLAC_IFG_INC		(1 << 23)
+
+/*
+ * DMA FIFO status register
+ */
+#define FTGMAC100_DMAFIFOS_RXDMA1_SM(dmafifos)	((dmafifos) & 0xf)
+#define FTGMAC100_DMAFIFOS_RXDMA2_SM(dmafifos)	(((dmafifos) >> 4) & 0xf)
+#define FTGMAC100_DMAFIFOS_RXDMA3_SM(dmafifos)	(((dmafifos) >> 8) & 0x7)
+#define FTGMAC100_DMAFIFOS_TXDMA1_SM(dmafifos)	(((dmafifos) >> 12) & 0xf)
+#define FTGMAC100_DMAFIFOS_TXDMA2_SM(dmafifos)	(((dmafifos) >> 16) & 0x3)
+#define FTGMAC100_DMAFIFOS_TXDMA3_SM(dmafifos)	(((dmafifos) >> 18) & 0xf)
+#define FTGMAC100_DMAFIFOS_RXFIFO_EMPTY		(1 << 26)
+#define FTGMAC100_DMAFIFOS_TXFIFO_EMPTY		(1 << 27)
+#define FTGMAC100_DMAFIFOS_RXDMA_GRANT		(1 << 28)
+#define FTGMAC100_DMAFIFOS_TXDMA_GRANT		(1 << 29)
+#define FTGMAC100_DMAFIFOS_RXDMA_REQ		(1 << 30)
+#define FTGMAC100_DMAFIFOS_TXDMA_REQ		(1 << 31)
+
+/*
+ * Receive buffer size register
+ */
+#define FTGMAC100_RBSR_SIZE(x)		((x) & 0x3fff)
+
+/*
+ * MAC control register
+ */
+#define FTGMAC100_MACCR_TXDMA_EN	(1 << 0)
+#define FTGMAC100_MACCR_RXDMA_EN	(1 << 1)
+#define FTGMAC100_MACCR_TXMAC_EN	(1 << 2)
+#define FTGMAC100_MACCR_RXMAC_EN	(1 << 3)
+#define FTGMAC100_MACCR_RM_VLAN		(1 << 4)
+#define FTGMAC100_MACCR_HPTXR_EN	(1 << 5)
+#define FTGMAC100_MACCR_LOOP_EN		(1 << 6)
+#define FTGMAC100_MACCR_ENRX_IN_HALFTX	(1 << 7)
+#define FTGMAC100_MACCR_FULLDUP		(1 << 8)
+#define FTGMAC100_MACCR_GIGA_MODE	(1 << 9)
+#define FTGMAC100_MACCR_CRC_APD		(1 << 10)
+#define FTGMAC100_MACCR_RX_RUNT		(1 << 12)
+#define FTGMAC100_MACCR_JUMBO_LF	(1 << 13)
+#define FTGMAC100_MACCR_RX_ALL		(1 << 14)
+#define FTGMAC100_MACCR_HT_MULTI_EN	(1 << 15)
+#define FTGMAC100_MACCR_RX_MULTIPKT	(1 << 16)
+#define FTGMAC100_MACCR_RX_BROADPKT	(1 << 17)
+#define FTGMAC100_MACCR_DISCARD_CRCERR	(1 << 18)
+#define FTGMAC100_MACCR_FAST_MODE	(1 << 19)
+#define FTGMAC100_MACCR_SW_RST		(1 << 31)
+
+/*
+ * PHY control register
+ */
+#define FTGMAC100_PHYCR_MDC_CYCTHR_MASK	0x3f
+#define FTGMAC100_PHYCR_MDC_CYCTHR(x)	((x) & 0x3f)
+#define FTGMAC100_PHYCR_PHYAD(x)	(((x) & 0x1f) << 16)
+#define FTGMAC100_PHYCR_REGAD(x)	(((x) & 0x1f) << 21)
+#define FTGMAC100_PHYCR_MIIRD		(1 << 26)
+#define FTGMAC100_PHYCR_MIIWR		(1 << 27)
+
+/*
+ * PHY data register
+ */
+#define FTGMAC100_PHYDATA_MIIWDATA(x)		((x) & 0xffff)
+#define FTGMAC100_PHYDATA_MIIRDATA(phydata)	(((phydata) >> 16) & 0xffff)
+
+/*
+ * Transmit descriptor, aligned to 16 bytes
+ */
+struct ftgmac100_txdes {
+	unsigned int	txdes0;
+	unsigned int	txdes1;
+	unsigned int	txdes2;	/* not used by HW */
+	unsigned int	txdes3;	/* TXBUF_BADR */
+} __attribute__ ((aligned(16)));
+
+#define FTGMAC100_TXDES0_TXBUF_SIZE(x)	((x) & 0x3fff)
+#define FTGMAC100_TXDES0_EDOTR		(1 << 15)
+#define FTGMAC100_TXDES0_CRC_ERR	(1 << 19)
+#define FTGMAC100_TXDES0_LTS		(1 << 28)
+#define FTGMAC100_TXDES0_FTS		(1 << 29)
+#define FTGMAC100_TXDES0_TXDMA_OWN	(1 << 31)
+
+#define FTGMAC100_TXDES1_VLANTAG_CI(x)	((x) & 0xffff)
+#define FTGMAC100_TXDES1_INS_VLANTAG	(1 << 16)
+#define FTGMAC100_TXDES1_TCP_CHKSUM	(1 << 17)
+#define FTGMAC100_TXDES1_UDP_CHKSUM	(1 << 18)
+#define FTGMAC100_TXDES1_IP_CHKSUM	(1 << 19)
+#define FTGMAC100_TXDES1_LLC		(1 << 22)
+#define FTGMAC100_TXDES1_TX2FIC		(1 << 30)
+#define FTGMAC100_TXDES1_TXIC		(1 << 31)
+
+/*
+ * Receive descriptor, aligned to 16 bytes
+ */
+struct ftgmac100_rxdes {
+	unsigned int	rxdes0;
+	unsigned int	rxdes1;
+	unsigned int	rxdes2;	/* not used by HW */
+	unsigned int	rxdes3;	/* RXBUF_BADR */
+} __attribute__ ((aligned(16)));
+
+#define FTGMAC100_RXDES0_VDBC		0x3fff
+#define FTGMAC100_RXDES0_EDORR		(1 << 15)
+#define FTGMAC100_RXDES0_MULTICAST	(1 << 16)
+#define FTGMAC100_RXDES0_BROADCAST	(1 << 17)
+#define FTGMAC100_RXDES0_RX_ERR		(1 << 18)
+#define FTGMAC100_RXDES0_CRC_ERR	(1 << 19)
+#define FTGMAC100_RXDES0_FTL		(1 << 20)
+#define FTGMAC100_RXDES0_RUNT		(1 << 21)
+#define FTGMAC100_RXDES0_RX_ODD_NB	(1 << 22)
+#define FTGMAC100_RXDES0_FIFO_FULL	(1 << 23)
+#define FTGMAC100_RXDES0_PAUSE_OPCODE	(1 << 24)
+#define FTGMAC100_RXDES0_PAUSE_FRAME	(1 << 25)
+#define FTGMAC100_RXDES0_LRS		(1 << 28)
+#define FTGMAC100_RXDES0_FRS		(1 << 29)
+#define FTGMAC100_RXDES0_RXPKT_RDY	(1 << 31)
+
+#define FTGMAC100_RXDES1_VLANTAG_CI	0xffff
+#define FTGMAC100_RXDES1_PROT_MASK	(0x3 << 20)
+#define FTGMAC100_RXDES1_PROT_NONIP	(0x0 << 20)
+#define FTGMAC100_RXDES1_PROT_IP	(0x1 << 20)
+#define FTGMAC100_RXDES1_PROT_TCPIP	(0x2 << 20)
+#define FTGMAC100_RXDES1_PROT_UDPIP	(0x3 << 20)
+#define FTGMAC100_RXDES1_LLC		(1 << 22)
+#define FTGMAC100_RXDES1_DF		(1 << 23)
+#define FTGMAC100_RXDES1_VLANTAG_AVAIL	(1 << 24)
+#define FTGMAC100_RXDES1_TCP_CHKSUM_ERR	(1 << 25)
+#define FTGMAC100_RXDES1_UDP_CHKSUM_ERR	(1 << 26)
+#define FTGMAC100_RXDES1_IP_CHKSUM_ERR	(1 << 27)
+
+struct ftgmac100_eth_data
+{
+    unsigned char   dev_addr[6];    //MAC address
+};
+
+#endif /* __FTGMAC100_H */
-- 
1.9.1

